<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark Background Demo</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.12em; text-transform: uppercase; z-index: 10; }
    #gyroPermission { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.78); color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; padding: 32px; z-index: 9; }
    #gyroPermission > div { max-width: 320px; }
    #gyroPermission button { margin-top: 20px; padding: 10px 28px; border: 1px solid rgba(255, 255, 255, 0.7); background: transparent; color: #fff; font-size: 0.82rem; letter-spacing: 0.12em; cursor: pointer; }
    #gyroPermission button:active { background: rgba(255, 255, 255, 0.1); }
    #scoreDisplay { position: fixed; top: 24px; left: 24px; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; font-size: 0.9rem; text-transform: uppercase; z-index: 8; pointer-events: none; }
    #crosshair { position: fixed; top: 50%; left: 50%; width: 28px; height: 28px; transform: translate(-50%, -50%); pointer-events: none; z-index: 8; opacity: 0.7; }
    #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    #crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #crosshair .circle { position: absolute; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.4); top: 50%; left: 50%; transform: translate(-50%, -50%); }
    #crosshair.flash { animation: crosshairFlash 0.2s ease-out; }
    @keyframes crosshairFlash { 0% { transform: translate(-50%, -50%) scale(1.3); } 100% { transform: translate(-50%, -50%) scale(1); } }
    #shootButton { position: fixed; bottom: 24px; left: 24px; width: 104px; height: 104px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.75); display: flex; align-items: center; justify-content: center; font-family: system-ui, sans-serif; font-size: 0.78rem; letter-spacing: 0.12em; color: #fff; background: rgba(255, 255, 255, 0.05); z-index: 7; cursor: pointer; user-select: none; touch-action: none; }
    #shootButton::before { content: ''; position: absolute; inset: 10%; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.35); }
    #shootButton::after { content: ''; position: absolute; inset: 24%; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.2); }
    #shootButton span { position: relative; z-index: 1; margin-top: 26px; opacity: 0.75; }
    #shootButton:active { background: rgba(255, 255, 255, 0.12); }
    .shoot-crosshair { position: absolute; width: 54px; height: 54px; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.6; }
    .shoot-crosshair::before, .shoot-crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    .shoot-crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    .shoot-crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #mobileUI { position: fixed; bottom: 24px; right: 24px; display: none; z-index: 6; pointer-events: none; }
    #moveJoystick { width: 120px; height: 120px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.35); background: rgba(255, 255, 255, 0.06); position: relative; pointer-events: auto; touch-action: none; }
    #moveJoystick::before { content: ''; position: absolute; inset: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.15); }
    #moveStick { position: absolute; width: 60px; height: 60px; border-radius: 50%; background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.45); top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s ease; }
    #moveStick::before, #moveStick::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.35); }
    #moveStick::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #moveStick::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="gyroPermission">
    <div>
      <p>Enable gyroscope aim for mobile.</p>
      <button id="requestGyro">Enable Gyro</button>
    </div>
  </div>
  <div id="scoreDisplay">Targets: 0 / 20</div>
  <div id="crosshair"><div class="circle"></div></div>
  <div id="shootButton">
    <div class="shoot-crosshair"></div>
    <span>SHOOT</span>
  </div>
  <div id="mobileUI">
    <div id="moveJoystick">
      <div id="moveStick"></div>
    </div>
  </div>
  <script type="module">
    import * as THREE from "three";
    import { SparkRenderer, SplatMesh } from "@sparkjsdev/spark";

    const SPZ_URL = "https://space-gimu.s3.ap-northeast-1.amazonaws.com/space.spz";
    const MOVE_SPEED = 2.5;
    const POINTER_SENSITIVITY = 0.002;
    const PITCH_LIMIT = Math.PI / 2 - 0.01;
    const BULLET_SPEED = 40;
    const BULLET_LIFETIME = 1.5;
    const ROUND_DURATION = 60;
    const MAX_ACTIVE_TARGETS = 20;
    const SCORE_STORAGE_KEY = "meteorHighScore";

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.style.cursor = "grab";
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = "YXZ";
    camera.position.set(0, 1.6, 3.5);
    const initialLookTarget = new THREE.Vector3(0, 1.6, -20);
    camera.lookAt(initialLookTarget);

    // 隕石の陰影表示用ライト
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
    directionalLight.position.set(3, 5, 2);
    scene.add(directionalLight);

    const cameraEuler = new THREE.Euler(0, 0, 0, "YXZ");
    cameraEuler.setFromQuaternion(camera.quaternion);
    let pitch = cameraEuler.x;
    let yaw = cameraEuler.y;

    const isMobile = /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
    const gyroPermissionEl = document.getElementById("gyroPermission");
    const requestGyroButton = document.getElementById("requestGyro");
    const mobileUI = document.getElementById("mobileUI");
    const moveJoystick = document.getElementById("moveJoystick");
    const moveStick = document.getElementById("moveStick");
    const shootButton = document.getElementById("shootButton");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const crosshair = document.getElementById("crosshair");

    let gyroControls = null;
    let gyroActive = false;
    let isGyroAvailable = false;
    let pointerLocked = false;
    let moveJoystickData = { x: 0, y: 0 };
    let touchLookActive = false;
    let lastTouchX = 0;
    let lastTouchY = 0;

    const targets = [];
    const bullets = [];
    const fragments = [];
    let score = 0;
    let bestScore = 0;
    let roundActive = false;
    let roundEnded = false;
    let timeRemaining = ROUND_DURATION;

    // 隕石ターゲット用マテリアル（通常のシェーディング）
    const meteorMaterial = new THREE.MeshStandardMaterial({ color: 0x8d8a84, roughness: 0.95, metalness: 0.08 });
    const meteorAccentMaterial = new THREE.MeshStandardMaterial({ color: 0x6e6b66, roughness: 0.98, metalness: 0.05 });
    const bulletGeometry = new THREE.SphereGeometry(0.15, 12, 12);
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

    const cameraWorldPosition = new THREE.Vector3();
    const targetWorldPosition = new THREE.Vector3();

    function applyCameraRotation() {
      cameraEuler.set(pitch, yaw, 0);
      camera.quaternion.setFromEuler(cameraEuler);
    }

    function flashCrosshair() {
      if (!crosshair) return;
      crosshair.classList.remove("flash");
      // Force reflow to restart animation
      void crosshair.offsetWidth;
      crosshair.classList.add("flash");
    }

    function updateScoreDisplay() {
      if (!scoreDisplay) return;
      if (roundActive) {
        const timeText = Math.max(0, timeRemaining).toFixed(1);
        scoreDisplay.textContent = `Score: ${score}  Best: ${bestScore}  Time: ${timeText}s`;
      } else if (roundEnded) {
        scoreDisplay.textContent = `Time Up! Score: ${score}  Best: ${bestScore}  Shoot to restart`;
      } else {
        scoreDisplay.textContent = `Shoot to start  Best: ${bestScore}`;
      }
    }

    function createGyroControls() {
      const deviceOrientation = { alpha: null, beta: null, gamma: null };
      let screenOrientation = window.orientation || 0;
      const zee = new THREE.Vector3(0, 0, 1);
      const euler = new THREE.Euler();
      const q0 = new THREE.Quaternion();
      const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

      const onDeviceOrientationChangeEvent = (event) => {
        deviceOrientation.alpha = event.alpha;
        deviceOrientation.beta = event.beta;
        deviceOrientation.gamma = event.gamma;
      };

      const onScreenOrientationChangeEvent = () => {
        screenOrientation = window.orientation || 0;
      };

      return {
        connect() {
          onScreenOrientationChangeEvent();
          window.addEventListener("orientationchange", onScreenOrientationChangeEvent);
          window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent);
        },
        disconnect() {
          window.removeEventListener("orientationchange", onScreenOrientationChangeEvent);
          window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent);
        },
        update() {
          if (deviceOrientation.alpha === null && deviceOrientation.beta === null && deviceOrientation.gamma === null) {
            return;
          }

          const alpha = deviceOrientation.alpha !== null ? THREE.MathUtils.degToRad(deviceOrientation.alpha) : 0;
          const beta = deviceOrientation.beta !== null ? THREE.MathUtils.degToRad(deviceOrientation.beta) : 0;
          const gamma = deviceOrientation.gamma !== null ? THREE.MathUtils.degToRad(deviceOrientation.gamma) : 0;
          const orient = THREE.MathUtils.degToRad(screenOrientation);

          euler.set(beta, alpha, -gamma, "YXZ");
          camera.quaternion.setFromEuler(euler);
          camera.quaternion.multiply(q1);
          camera.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));

          cameraEuler.setFromQuaternion(camera.quaternion);
          pitch = cameraEuler.x;
          yaw = cameraEuler.y;
        }
      };
    }

    async function setupGyroscope() {
      if (!isMobile || gyroActive || typeof DeviceOrientationEvent === "undefined") {
        return false;
      }

      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== "granted") {
            return false;
          }
        } catch (error) {
          console.error("Failed to enable gyroscope:", error);
          return false;
        }
      }

      if (!gyroControls) {
        gyroControls = createGyroControls();
        gyroControls.connect();
      }

      gyroActive = true;
      isGyroAvailable = true;
      touchLookActive = false;

      if (document.pointerLockElement) {
        document.exitPointerLock();
      }

      pointerLocked = false;
      renderer.domElement.style.cursor = "auto";

      if (gyroPermissionEl) {
        gyroPermissionEl.style.display = "none";
      }

      return true;
    }

    function setupJoystick(container, stick, callback) {
      let active = false;
      let currentX = 0;
      let currentY = 0;
      const maxDistance = 45;

      function updateStickPosition() {
        stick.style.transform = `translate(calc(-50% + ${currentX}px), calc(-50% + ${currentY}px))`;
      }

      function handleStart(e) {
        active = true;
        if (e.cancelable !== false) e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = container.getBoundingClientRect();
        currentX = touch.clientX - rect.left - rect.width / 2;
        currentY = touch.clientY - rect.top - rect.height / 2;

        const distance = Math.sqrt(currentX * currentX + currentY * currentY);
        if (distance > maxDistance) {
          currentX = (currentX / distance) * maxDistance;
          currentY = (currentY / distance) * maxDistance;
        }

        updateStickPosition();
        callback({ x: currentX / maxDistance, y: currentY / maxDistance });
      }

      function handleMove(e) {
        if (!active) return;
        if (e.cancelable !== false) e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = container.getBoundingClientRect();
        currentX = touch.clientX - rect.left - rect.width / 2;
        currentY = touch.clientY - rect.top - rect.height / 2;

        const distance = Math.sqrt(currentX * currentX + currentY * currentY);
        if (distance > maxDistance) {
          currentX = (currentX / distance) * maxDistance;
          currentY = (currentY / distance) * maxDistance;
        }

        updateStickPosition();
        callback({ x: currentX / maxDistance, y: currentY / maxDistance });
      }

      function handleEnd() {
        active = false;
        currentX = 0;
        currentY = 0;
        updateStickPosition();
        callback({ x: 0, y: 0 });
      }

      container.addEventListener("touchstart", handleStart, { passive: false });
      document.addEventListener("touchmove", handleMove, { passive: false });
      document.addEventListener("touchend", handleEnd);
      document.addEventListener("touchcancel", handleEnd);

      container.addEventListener("mousedown", handleStart);
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", handleEnd);

      updateStickPosition();
    }

    function onTouchStartLook(event) {
      if (!isMobile || gyroActive) return;
      if (event.target && typeof event.target.closest === 'function') {
        if (event.target.closest('#moveJoystick') || event.target.closest('#shootButton')) {
          return;
        }
      }
      const touch = event.touches && event.touches[0];
      if (!touch) return;
      touchLookActive = true;
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      if (event.cancelable !== false) event.preventDefault();
    }

    function onTouchMoveLook(event) {
      if (!touchLookActive || gyroActive) return;
      const touch = event.touches && event.touches[0];
      if (!touch) return;
      const deltaX = touch.clientX - lastTouchX;
      const deltaY = touch.clientY - lastTouchY;
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      yaw -= deltaX * POINTER_SENSITIVITY;
      pitch -= deltaY * POINTER_SENSITIVITY;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyCameraRotation();
      if (event.cancelable !== false) event.preventDefault();
    }

    function onTouchEndLook() {
      touchLookActive = false;
    }

    if (requestGyroButton) {
      requestGyroButton.addEventListener("click", async () => {
        const enabled = await setupGyroscope();
        if (!enabled && gyroPermissionEl) {
          gyroPermissionEl.style.display = "flex";
        }
      });
    }

    if (isMobile && gyroPermissionEl && typeof DeviceOrientationEvent !== "undefined") {
      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        gyroPermissionEl.style.display = "flex";
      } else {
        setupGyroscope();
      }
    }

    if (isMobile) {
      if (mobileUI) mobileUI.style.display = "block";
      renderer.domElement.style.touchAction = "none";
      if (moveJoystick && moveStick) {
        setupJoystick(moveJoystick, moveStick, (data) => {
          moveJoystickData = data;
        });
      }
    }

    const spark = new SparkRenderer({
      renderer,
      maxStdDev: Math.sqrt(5),
      maxPixelRadius: 256,
      clipXY: 1.2,
      view: { stochastic: false, sortRadial: true, sortDistance: 0.01, sortCoorient: 0.995, sort32: false }
    });
    scene.add(spark);

    const loadingEl = document.getElementById("loading");
    const splat = new SplatMesh({
      url: SPZ_URL,
      onLoad: () => {
        if (loadingEl) loadingEl.remove();
        renderer.render(scene, camera);
      }
    });

    splat.scale.setScalar(3);
    splat.position.set(0, 0, -6);
    splat.rotation.set(0, 0, 0);
    splat.rotateX(Math.PI);
    scene.add(splat);

    function createMeteorMesh(radius = 1.2) {
      // 低ポリ隕石: 正二十面体をノイズで歪ませる
      const geom = new THREE.IcosahedronGeometry(radius, 1);
      const pos = geom.attributes.position;
      const tmp = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        tmp.fromBufferAttribute(pos, i);
        const n = tmp.clone().normalize();
        const noise = (Math.sin(tmp.x * 2.3) + Math.sin(tmp.y * 1.7) + Math.sin(tmp.z * 2.9)) * 0.12;
        const scale = 1 + noise + (Math.random() - 0.5) * 0.06;
        tmp.copy(n).multiplyScalar(radius * scale);
        pos.setXYZ(i, tmp.x, tmp.y, tmp.z);
      }
      geom.computeVertexNormals();
      const core = new THREE.Mesh(geom, meteorMaterial.clone());

      // 表面の岩片（小さな起伏）
      const group = new THREE.Group();
      group.add(core);
      const bumps = 5 + Math.floor(Math.random() * 4);
      for (let i = 0; i < bumps; i++) {
        const b = new THREE.IcosahedronGeometry(radius * THREE.MathUtils.randFloat(0.12, 0.22), 0);
        const m = new THREE.Mesh(b, meteorAccentMaterial.clone());
        // ランダムな位置に付ける
        const dir = new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 2 - 1,
          Math.random() * 2 - 1
        ).normalize();
        const dist = radius * THREE.MathUtils.randFloat(0.8, 1.05);
        m.position.copy(dir.multiplyScalar(dist));
        m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        group.add(m);
      }
      return group;
    }

    function createTarget(x, y, z, options = {}) {
      const { velocity = null, maxLife = null } = options;
      const group = new THREE.Group();
      const meteor = createMeteorMesh(1.8);
      group.add(meteor);
      group.position.set(x, y, z);
      // 隕石は自転させる
      const spinAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
      const spinSpeed = THREE.MathUtils.randFloat(0.4, 1.0);
      const fallVelocity = velocity ? velocity.clone() : new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(0.4),
        -THREE.MathUtils.randFloat(0.25, 0.5),
        THREE.MathUtils.randFloat(0.4, 1.1)
      );
      const lifespan = maxLife ?? THREE.MathUtils.randFloat(9, 14);
      group.scale.setScalar(1);
      group.userData = {
        hit: false,
        fade: 0,
        radius: 1.8,
        spinAxis,
        spinSpeed,
        velocity: fallVelocity,
        life: 0,
        maxLife: lifespan
      };
      scene.add(group);
      targets.push(group);
    }

    function createShatter(position) {
      const count = 16 + Math.floor(Math.random() * 10);
      for (let i = 0; i < count; i++) {
        const r = THREE.MathUtils.randFloat(0.18, 0.35);
        const geom = new THREE.IcosahedronGeometry(r, 0);
        const useAccent = Math.random() < 0.45;
        const mat = (useAccent ? meteorAccentMaterial : meteorMaterial).clone();
        mat.transparent = true;
        const piece = new THREE.Mesh(geom, mat);
        piece.position.copy(position);
        piece.position.x += (Math.random() - 0.5) * 0.3;
        piece.position.y += (Math.random() - 0.5) * 0.3;
        piece.position.z += (Math.random() - 0.5) * 0.3;
        piece.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        const dir = new THREE.Vector3(Math.random() - 0.5, Math.random(), Math.random() - 0.5).normalize();
        const speed = THREE.MathUtils.randFloat(4, 9);
        const angVel = new THREE.Vector3(
          THREE.MathUtils.randFloat(-6, 6),
          THREE.MathUtils.randFloat(-6, 6),
          THREE.MathUtils.randFloat(-6, 6)
        );
        fragments.push({ mesh: piece, velocity: dir.multiplyScalar(speed), life: 1.2, angular: angVel });
        scene.add(piece);
      }
    }

    function spawnRandomTarget() {
      const minX = -24;
      const maxX = 24;
      const minZ = -72;
      const maxZ = -28;
      const minY = 6.5;
      const maxY = 11.0;
      const minSeparation = 5;
      const maxAttemptsPerTarget = 300;
      const candidate = new THREE.Vector3();

      let placed = false;
      let attempts = 0;

      while (!placed && attempts < maxAttemptsPerTarget) {
        candidate.set(
          THREE.MathUtils.randFloat(minX, maxX),
          THREE.MathUtils.randFloat(minY, maxY),
          THREE.MathUtils.randFloat(minZ, maxZ)
        );

        let tooClose = false;
        for (let j = 0; j < targets.length; j++) {
          if (candidate.distanceToSquared(targets[j].position) < minSeparation * minSeparation) {
            tooClose = true;
            break;
          }
        }

        if (!tooClose) {
          const lateralX = THREE.MathUtils.randFloatSpread(0.6);
          const downward = THREE.MathUtils.randFloat(0.25, 0.45);
          const forward = THREE.MathUtils.randFloat(0.6, 1.4);
          const meteorVelocity = new THREE.Vector3(lateralX, -downward, forward);
          const maxLife = THREE.MathUtils.randFloat(8, 13);
          createTarget(candidate.x, candidate.y, candidate.z, { velocity: meteorVelocity, maxLife });
          placed = true;
        }

        attempts++;
      }

      if (!placed) {
        const fallbackVelocity = new THREE.Vector3(
          THREE.MathUtils.randFloatSpread(0.6),
          -THREE.MathUtils.randFloat(0.25, 0.45),
          THREE.MathUtils.randFloat(0.6, 1.4)
        );
        const maxLife = THREE.MathUtils.randFloat(8, 13);
        createTarget(
          THREE.MathUtils.randFloat(minX, maxX),
          THREE.MathUtils.randFloat(minY, maxY),
          THREE.MathUtils.randFloat(minZ, maxZ),
          { velocity: fallbackVelocity, maxLife }
        );
      }
    }

    function fillTargets() {
      while (targets.length < MAX_ACTIVE_TARGETS) {
        spawnRandomTarget();
      }
    }

    function clearTargets() {
      for (let i = targets.length - 1; i >= 0; i--) {
        scene.remove(targets[i]);
      }
      targets.length = 0;
    }

    function clearBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        scene.remove(bullets[i].mesh);
      }
      bullets.length = 0;
    }

    function clearFragments() {
      for (let i = fragments.length - 1; i >= 0; i--) {
        scene.remove(fragments[i].mesh);
      }
      fragments.length = 0;
    }

    function startRound() {
      if (roundActive) return;
      const shouldResetTargets = roundEnded || targets.length === 0;
      roundActive = true;
      roundEnded = false;
      timeRemaining = ROUND_DURATION;
      score = 0;
      clearBullets();
      clearFragments();
      if (shouldResetTargets) {
        clearTargets();
      }
      fillTargets();
      updateScoreDisplay();
    }

    function endRound() {
      if (!roundActive) return;
      roundActive = false;
      roundEnded = true;
      timeRemaining = 0;
      clearBullets();
      if (score > bestScore) {
        bestScore = score;
        try {
          localStorage.setItem(SCORE_STORAGE_KEY, String(bestScore));
        } catch (error) {
          console.warn("Failed to store high score:", error);
        }
      }
      updateScoreDisplay();
    }

    function handleTargetHit(target) {
      if (target.userData.hit) return;
      target.userData.hit = true;
      // 破片を生成
      const pos = new THREE.Vector3();
      target.getWorldPosition(pos);
      createShatter(pos);
      // ターゲットを即時削除
      const idx = targets.indexOf(target);
      if (idx !== -1) {
        scene.remove(target);
        targets.splice(idx, 1);
      }
      if (roundActive) {
        score++;
        spawnRandomTarget();
        updateScoreDisplay();
      }
    }

    function updateFragments(delta) {
      for (let i = fragments.length - 1; i >= 0; i--) {
        const f = fragments[i];
        f.life -= delta;
        // 移動 & 重力
        f.mesh.position.addScaledVector(f.velocity, delta);
        f.velocity.y -= 9.8 * delta * 0.6;
        // 回転
        f.mesh.rotation.x += f.angular.x * delta;
        f.mesh.rotation.y += f.angular.y * delta;
        f.mesh.rotation.z += f.angular.z * delta;
        // フェード
        const t = Math.max(0, f.life / 1.2);
        if (f.mesh.material && 'opacity' in f.mesh.material) {
          f.mesh.material.opacity = t;
        }
        if (f.life <= 0) {
          scene.remove(f.mesh);
          fragments.splice(i, 1);
        }
      }
    }

    function createBullet() {
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial.clone());
      const startPosition = new THREE.Vector3();
      const direction = new THREE.Vector3();
      camera.getWorldPosition(startPosition);
      camera.getWorldDirection(direction);
      direction.normalize();
      bullet.position.copy(startPosition);
      bullet.position.add(direction.clone().multiplyScalar(0.6));
      scene.add(bullet);
      bullets.push({ mesh: bullet, velocity: direction.multiplyScalar(BULLET_SPEED), life: BULLET_LIFETIME });
    }

    function shoot() {
      if (!roundActive) {
        startRound();
      }
      if (!roundActive) return;
      createBullet();
      flashCrosshair();
    }

    function updateBullets(delta) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bulletData = bullets[i];
        bulletData.life -= delta;
        bulletData.mesh.position.addScaledVector(bulletData.velocity, delta);

        if (bulletData.life <= 0) {
          scene.remove(bulletData.mesh);
          bullets.splice(i, 1);
          continue;
        }

        let hitTarget = false;
        for (let j = targets.length - 1; j >= 0; j--) {
          const target = targets[j];
          if (target.userData.hit) continue;
          target.getWorldPosition(targetWorldPosition);
          const radius = target.userData.radius * target.scale.x;
          if (bulletData.mesh.position.distanceTo(targetWorldPosition) <= radius) {
            handleTargetHit(target);
            scene.remove(bulletData.mesh);
            bullets.splice(i, 1);
            hitTarget = true;
            break;
          }
        }

        if (hitTarget) {
          continue;
        }
      }
    }

    function updateTargets(delta) {
      for (let i = targets.length - 1; i >= 0; i--) {
        const target = targets[i];
        const data = target.userData || {};
        if (!data.hit) {
          // 自転
          if (data.spinAxis && typeof data.spinSpeed === "number") {
            const angle = data.spinSpeed * delta;
            target.rotateOnAxis(data.spinAxis, angle);
          }

          if (data.velocity instanceof THREE.Vector3) {
            target.position.addScaledVector(data.velocity, delta);
          }

          if (typeof data.life === "number" && typeof data.maxLife === "number" && data.maxLife > 0) {
            data.life += delta;
            const lifeRatio = THREE.MathUtils.clamp(data.life / data.maxLife, 0, 1);
            const scale = Math.max(0, 1 - lifeRatio);
            target.scale.setScalar(scale);
            if (scale <= 0.05 || target.position.y <= 0.6) {
              scene.remove(target);
              targets.splice(i, 1);
              spawnRandomTarget();
              continue;
            }
          }
        } else {
          data.fade += delta;
          const scale = Math.max(0, 1 - data.fade * 3);
          target.scale.setScalar(scale);
          if (scale <= 0.05) {
            scene.remove(target);
            targets.splice(i, 1);
          }
        }
      }
    }

    if (shootButton) {
      shootButton.addEventListener("click", (event) => {
        event.preventDefault();
        shoot();
      });
      shootButton.addEventListener("touchstart", (event) => {
        if (event.cancelable !== false) event.preventDefault();
        shoot();
      }, { passive: false });
    }

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0 && !isMobile && !gyroActive && pointerLocked) {
        shoot();
      }
    });

    renderer.domElement.addEventListener("click", () => {
      if (gyroActive || isMobile) return;
      if (!pointerLocked) {
        renderer.domElement.requestPointerLock();
      }
    });

    document.addEventListener("pointerlockchange", () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
      renderer.domElement.style.cursor = pointerLocked ? "none" : (gyroActive ? "auto" : "grab");
    });

    renderer.domElement.addEventListener("touchstart", onTouchStartLook, { passive: false });
    renderer.domElement.addEventListener("touchmove", onTouchMoveLook, { passive: false });
    renderer.domElement.addEventListener("touchend", onTouchEndLook);
    renderer.domElement.addEventListener("touchcancel", onTouchEndLook);

    document.addEventListener("mousemove", (event) => {
      if (!pointerLocked || gyroActive) return;
      yaw -= event.movementX * POINTER_SENSITIVITY;
      pitch -= event.movementY * POINTER_SENSITIVITY;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyCameraRotation();
    });

    function handleResize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    handleResize();
    window.addEventListener("resize", handleResize);

    const clock = new THREE.Clock();
    const worldUp = new THREE.Vector3(0, 1, 0);
    const inputVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const displacement = new THREE.Vector3();

    try {
      const storedBest = localStorage.getItem(SCORE_STORAGE_KEY);
      if (storedBest !== null) {
        const parsedBest = Number.parseInt(storedBest, 10);
        if (!Number.isNaN(parsedBest) && parsedBest > 0) {
          bestScore = parsedBest;
        }
      }
    } catch (error) {
      console.warn("Failed to read high score:", error);
    }

    fillTargets();
    updateScoreDisplay();

    function updateMovement(delta) {
      const joystickX = Math.abs(moveJoystickData.x) > 0.01 ? moveJoystickData.x : 0;
      const joystickY = Math.abs(moveJoystickData.y) > 0.01 ? moveJoystickData.y : 0;

      inputVector.set(joystickX, 0, -joystickY);

      if (inputVector.x === 0 && inputVector.z === 0) return;

      if (inputVector.lengthSq() > 1) {
        inputVector.normalize();
      }

      forwardVector.set(0, 0, -1).applyQuaternion(camera.quaternion);
      forwardVector.y = 0;
      if (forwardVector.lengthSq() > 0.0001) {
        forwardVector.normalize();
      } else {
        forwardVector.set(0, 0, -1);
      }

      rightVector.crossVectors(forwardVector, worldUp);
      if (rightVector.lengthSq() > 0.0001) {
        rightVector.normalize();
      } else {
        rightVector.set(1, 0, 0);
      }

      displacement.copy(forwardVector).multiplyScalar(inputVector.z);
      displacement.addScaledVector(rightVector, inputVector.x);

      if (displacement.lengthSq() === 0) return;

      displacement.normalize().multiplyScalar(MOVE_SPEED * delta);
      camera.position.add(displacement);
      camera.position.y = 1.6;
    }

    renderer.setAnimationLoop(() => {
      const delta = clock.getDelta();
      if (gyroActive && gyroControls && isGyroAvailable) {
        gyroControls.update();
      }
      if (roundActive) {
        timeRemaining = Math.max(0, timeRemaining - delta);
        if (timeRemaining <= 0) {
          endRound();
        } else {
          updateScoreDisplay();
        }
      }
      updateMovement(delta);
      updateBullets(delta);
      updateTargets(delta);
      updateFragments(delta);
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
