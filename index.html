<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark Background Demo</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.12em; text-transform: uppercase; z-index: 10; }
    #gyroPermission { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.78); color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; padding: 32px; z-index: 9; }
    #gyroPermission > div { max-width: 320px; }
    #gyroPermission button { margin-top: 20px; padding: 10px 28px; border: 1px solid rgba(255, 255, 255, 0.7); background: transparent; color: #fff; font-size: 0.82rem; letter-spacing: 0.12em; cursor: pointer; }
    #gyroPermission button:active { background: rgba(255, 255, 255, 0.1); }
    #scoreDisplay { position: fixed; top: 24px; left: 24px; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; font-size: 0.9rem; text-transform: uppercase; z-index: 8; pointer-events: none; }
    #crosshair { position: fixed; top: 50%; left: 50%; width: 28px; height: 28px; transform: translate(-50%, -50%); pointer-events: none; z-index: 8; opacity: 0.7; }
    #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    #crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #crosshair .circle { position: absolute; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.4); top: 50%; left: 50%; transform: translate(-50%, -50%); }
    #crosshair.flash { animation: crosshairFlash 0.2s ease-out; }
    @keyframes crosshairFlash { 0% { transform: translate(-50%, -50%) scale(1.3); } 100% { transform: translate(-50%, -50%) scale(1); } }
    #shootButton { position: fixed; bottom: 24px; left: 24px; width: 104px; height: 104px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.75); display: flex; align-items: center; justify-content: center; font-family: system-ui, sans-serif; font-size: 0.78rem; letter-spacing: 0.12em; color: #fff; background: rgba(255, 255, 255, 0.05); z-index: 7; cursor: pointer; user-select: none; touch-action: none; }
    #shootButton::before { content: ''; position: absolute; inset: 10%; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.35); }
    #shootButton::after { content: ''; position: absolute; inset: 24%; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.2); }
    #shootButton span { position: relative; z-index: 1; margin-top: 26px; opacity: 0.75; }
    #shootButton:active { background: rgba(255, 255, 255, 0.12); }
    .shoot-crosshair { position: absolute; width: 54px; height: 54px; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.6; }
    .shoot-crosshair::before, .shoot-crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    .shoot-crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    .shoot-crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #mobileUI { position: fixed; bottom: 24px; right: 24px; display: none; z-index: 6; pointer-events: none; }
    #moveJoystick { width: 120px; height: 120px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.35); background: rgba(255, 255, 255, 0.06); position: relative; pointer-events: auto; touch-action: none; }
    #moveJoystick::before { content: ''; position: absolute; inset: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.15); }
    #moveStick { position: absolute; width: 60px; height: 60px; border-radius: 50%; background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.45); top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s ease; }
    #moveStick::before, #moveStick::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.35); }
    #moveStick::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #moveStick::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="gyroPermission">
    <div>
      <p>Enable gyroscope aim for mobile.</p>
      <button id="requestGyro">Enable Gyro</button>
    </div>
  </div>
  <div id="scoreDisplay">Targets: 0 / 20</div>
  <div id="crosshair"><div class="circle"></div></div>
  <div id="shootButton">
    <div class="shoot-crosshair"></div>
    <span>SHOOT</span>
  </div>
  <div id="mobileUI">
    <div id="moveJoystick">
      <div id="moveStick"></div>
    </div>
  </div>
  <script type="module">
    import * as THREE from "three";
    import { SparkRenderer, SplatMesh } from "@sparkjsdev/spark";

    const SPZ_URL = "https://space-gimu.s3.ap-northeast-1.amazonaws.com/space.spz";
    const MOVE_SPEED = 2.5;
    const POINTER_SENSITIVITY = 0.002;
    const PITCH_LIMIT = Math.PI / 2 - 0.01;
    const BULLET_SPEED = 40;
    const BULLET_LIFETIME = 1.5;
    const TOTAL_TARGETS = 20;

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.style.cursor = "grab";
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = "YXZ";
    camera.position.set(0, 1.6, 3.5);
    const initialLookTarget = new THREE.Vector3(0, 1.6, -20);
    camera.lookAt(initialLookTarget);

    const cameraEuler = new THREE.Euler(0, 0, 0, "YXZ");
    cameraEuler.setFromQuaternion(camera.quaternion);
    let pitch = cameraEuler.x;
    let yaw = cameraEuler.y;

    const isMobile = /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
    const gyroPermissionEl = document.getElementById("gyroPermission");
    const requestGyroButton = document.getElementById("requestGyro");
    const mobileUI = document.getElementById("mobileUI");
    const moveJoystick = document.getElementById("moveJoystick");
    const moveStick = document.getElementById("moveStick");
    const shootButton = document.getElementById("shootButton");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const crosshair = document.getElementById("crosshair");

    let gyroControls = null;
    let gyroActive = false;
    let isGyroAvailable = false;
    let pointerLocked = false;
    let moveJoystickData = { x: 0, y: 0 };
    let touchLookActive = false;
    let lastTouchX = 0;
    let lastTouchY = 0;

    const targets = [];
    const bullets = [];

    const targetOuterGeometry = new THREE.TorusGeometry(1.5, 0.12, 16, 32);
    const targetMiddleGeometry = new THREE.TorusGeometry(0.95, 0.1, 12, 24);
    const targetInnerGeometry = new THREE.OctahedronGeometry(0.45);
    const targetOuterMaterial = new THREE.MeshBasicMaterial({ color: 0xff6f3c, wireframe: true });
    const targetMiddleMaterial = new THREE.MeshBasicMaterial({ color: 0xffc37a, wireframe: true });
    const targetInnerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    const bulletGeometry = new THREE.SphereGeometry(0.15, 12, 12);
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

    const cameraWorldPosition = new THREE.Vector3();
    const targetWorldPosition = new THREE.Vector3();

    function applyCameraRotation() {
      cameraEuler.set(pitch, yaw, 0);
      camera.quaternion.setFromEuler(cameraEuler);
    }

    function flashCrosshair() {
      if (!crosshair) return;
      crosshair.classList.remove("flash");
      // Force reflow to restart animation
      void crosshair.offsetWidth;
      crosshair.classList.add("flash");
    }

    function updateScoreDisplay() {
      if (!scoreDisplay) return;
      if (targetsHit >= TOTAL_TARGETS) {
        scoreDisplay.textContent = `Targets: ${targetsHit} / ${TOTAL_TARGETS} - CLEAR`;
      } else {
        scoreDisplay.textContent = `Targets: ${targetsHit} / ${TOTAL_TARGETS}`;
      }
    }

    function createGyroControls() {
      const deviceOrientation = { alpha: null, beta: null, gamma: null };
      let screenOrientation = window.orientation || 0;
      const zee = new THREE.Vector3(0, 0, 1);
      const euler = new THREE.Euler();
      const q0 = new THREE.Quaternion();
      const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

      const onDeviceOrientationChangeEvent = (event) => {
        deviceOrientation.alpha = event.alpha;
        deviceOrientation.beta = event.beta;
        deviceOrientation.gamma = event.gamma;
      };

      const onScreenOrientationChangeEvent = () => {
        screenOrientation = window.orientation || 0;
      };

      return {
        connect() {
          onScreenOrientationChangeEvent();
          window.addEventListener("orientationchange", onScreenOrientationChangeEvent);
          window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent);
        },
        disconnect() {
          window.removeEventListener("orientationchange", onScreenOrientationChangeEvent);
          window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent);
        },
        update() {
          if (deviceOrientation.alpha === null && deviceOrientation.beta === null && deviceOrientation.gamma === null) {
            return;
          }

          const alpha = deviceOrientation.alpha !== null ? THREE.MathUtils.degToRad(deviceOrientation.alpha) : 0;
          const beta = deviceOrientation.beta !== null ? THREE.MathUtils.degToRad(deviceOrientation.beta) : 0;
          const gamma = deviceOrientation.gamma !== null ? THREE.MathUtils.degToRad(deviceOrientation.gamma) : 0;
          const orient = THREE.MathUtils.degToRad(screenOrientation);

          euler.set(beta, alpha, -gamma, "YXZ");
          camera.quaternion.setFromEuler(euler);
          camera.quaternion.multiply(q1);
          camera.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));

          cameraEuler.setFromQuaternion(camera.quaternion);
          pitch = cameraEuler.x;
          yaw = cameraEuler.y;
        }
      };
    }

    async function setupGyroscope() {
      if (!isMobile || gyroActive || typeof DeviceOrientationEvent === "undefined") {
        return false;
      }

      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== "granted") {
            return false;
          }
        } catch (error) {
          console.error("Failed to enable gyroscope:", error);
          return false;
        }
      }

      if (!gyroControls) {
        gyroControls = createGyroControls();
        gyroControls.connect();
      }

      gyroActive = true;
      isGyroAvailable = true;
      touchLookActive = false;

      if (document.pointerLockElement) {
        document.exitPointerLock();
      }

      pointerLocked = false;
      renderer.domElement.style.cursor = "auto";

      if (gyroPermissionEl) {
        gyroPermissionEl.style.display = "none";
      }

      return true;
    }

    function setupJoystick(container, stick, callback) {
      let active = false;
      let currentX = 0;
      let currentY = 0;
      const maxDistance = 45;

      function updateStickPosition() {
        stick.style.transform = `translate(calc(-50% + ${currentX}px), calc(-50% + ${currentY}px))`;
      }

      function handleStart(e) {
        active = true;
        if (e.cancelable !== false) e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = container.getBoundingClientRect();
        currentX = touch.clientX - rect.left - rect.width / 2;
        currentY = touch.clientY - rect.top - rect.height / 2;

        const distance = Math.sqrt(currentX * currentX + currentY * currentY);
        if (distance > maxDistance) {
          currentX = (currentX / distance) * maxDistance;
          currentY = (currentY / distance) * maxDistance;
        }

        updateStickPosition();
        callback({ x: currentX / maxDistance, y: currentY / maxDistance });
      }

      function handleMove(e) {
        if (!active) return;
        if (e.cancelable !== false) e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = container.getBoundingClientRect();
        currentX = touch.clientX - rect.left - rect.width / 2;
        currentY = touch.clientY - rect.top - rect.height / 2;

        const distance = Math.sqrt(currentX * currentX + currentY * currentY);
        if (distance > maxDistance) {
          currentX = (currentX / distance) * maxDistance;
          currentY = (currentY / distance) * maxDistance;
        }

        updateStickPosition();
        callback({ x: currentX / maxDistance, y: currentY / maxDistance });
      }

      function handleEnd() {
        active = false;
        currentX = 0;
        currentY = 0;
        updateStickPosition();
        callback({ x: 0, y: 0 });
      }

      container.addEventListener("touchstart", handleStart, { passive: false });
      document.addEventListener("touchmove", handleMove, { passive: false });
      document.addEventListener("touchend", handleEnd);
      document.addEventListener("touchcancel", handleEnd);

      container.addEventListener("mousedown", handleStart);
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", handleEnd);

      updateStickPosition();
    }

    function onTouchStartLook(event) {
      if (!isMobile || gyroActive) return;
      if (event.target && typeof event.target.closest === 'function') {
        if (event.target.closest('#moveJoystick') || event.target.closest('#shootButton')) {
          return;
        }
      }
      const touch = event.touches && event.touches[0];
      if (!touch) return;
      touchLookActive = true;
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      if (event.cancelable !== false) event.preventDefault();
    }

    function onTouchMoveLook(event) {
      if (!touchLookActive || gyroActive) return;
      const touch = event.touches && event.touches[0];
      if (!touch) return;
      const deltaX = touch.clientX - lastTouchX;
      const deltaY = touch.clientY - lastTouchY;
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      yaw -= deltaX * POINTER_SENSITIVITY;
      pitch -= deltaY * POINTER_SENSITIVITY;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyCameraRotation();
      if (event.cancelable !== false) event.preventDefault();
    }

    function onTouchEndLook() {
      touchLookActive = false;
    }

    if (requestGyroButton) {
      requestGyroButton.addEventListener("click", async () => {
        const enabled = await setupGyroscope();
        if (!enabled && gyroPermissionEl) {
          gyroPermissionEl.style.display = "flex";
        }
      });
    }

    if (isMobile && gyroPermissionEl && typeof DeviceOrientationEvent !== "undefined") {
      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        gyroPermissionEl.style.display = "flex";
      } else {
        setupGyroscope();
      }
    }

    if (isMobile) {
      if (mobileUI) mobileUI.style.display = "block";
      renderer.domElement.style.touchAction = "none";
      if (moveJoystick && moveStick) {
        setupJoystick(moveJoystick, moveStick, (data) => {
          moveJoystickData = data;
        });
      }
    }

    const spark = new SparkRenderer({
      renderer,
      maxStdDev: Math.sqrt(5),
      maxPixelRadius: 256,
      clipXY: 1.2,
      view: { stochastic: false, sortRadial: true, sortDistance: 0.01, sortCoorient: 0.995, sort32: false }
    });
    scene.add(spark);

    const loadingEl = document.getElementById("loading");
    const splat = new SplatMesh({
      url: SPZ_URL,
      onLoad: () => {
        if (loadingEl) loadingEl.remove();
        renderer.render(scene, camera);
      }
    });

    splat.scale.setScalar(3);
    splat.position.set(0, 0, -6);
    splat.rotation.set(0, 0, 0);
    splat.rotateX(Math.PI);
    scene.add(splat);

    function createTarget(x, y, z) {
      const group = new THREE.Group();
      const outer = new THREE.Mesh(targetOuterGeometry, targetOuterMaterial);
      const middle = new THREE.Mesh(targetMiddleGeometry, targetMiddleMaterial);
      const inner = new THREE.Mesh(targetInnerGeometry, targetInnerMaterial);
      group.add(outer);
      group.add(middle);
      group.add(inner);
      group.position.set(x, y, z);
      group.userData = { hit: false, fade: 0, radius: 1.6 };
      scene.add(group);
      targets.push(group);
    }

    function createTargets() {
      const minX = -22;
      const maxX = 22;
      const minZ = -58;
      const maxZ = -18;
      const minY = 2.2;
      const maxY = 5.0;
      const minSeparation = 5;
      const maxAttemptsPerTarget = 300;
      const candidate = new THREE.Vector3();

      for (let i = 0; i < TOTAL_TARGETS; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < maxAttemptsPerTarget) {
          candidate.set(
            THREE.MathUtils.randFloat(minX, maxX),
            THREE.MathUtils.randFloat(minY, maxY),
            THREE.MathUtils.randFloat(minZ, maxZ)
          );

          let tooClose = false;
          for (let j = 0; j < targets.length; j++) {
            if (candidate.distanceToSquared(targets[j].position) < minSeparation * minSeparation) {
              tooClose = true;
              break;
            }
          }

          if (!tooClose) {
            createTarget(candidate.x, candidate.y, candidate.z);
            placed = true;
          }

          attempts++;
        }

        if (!placed) {
          // Fallback: place without separation constraint to ensure quota
          createTarget(
            THREE.MathUtils.randFloat(minX, maxX),
            THREE.MathUtils.randFloat(minY, maxY),
            THREE.MathUtils.randFloat(minZ, maxZ)
          );
        }
      }
    }

    function handleTargetHit(target) {
      if (target.userData.hit) return;
      target.userData.hit = true;
      target.userData.fade = 0;
      targetsHit++;
      updateScoreDisplay();
    }

    function createBullet() {
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial.clone());
      const startPosition = new THREE.Vector3();
      const direction = new THREE.Vector3();
      camera.getWorldPosition(startPosition);
      camera.getWorldDirection(direction);
      direction.normalize();
      bullet.position.copy(startPosition);
      bullet.position.add(direction.clone().multiplyScalar(0.6));
      scene.add(bullet);
      bullets.push({ mesh: bullet, velocity: direction.multiplyScalar(BULLET_SPEED), life: BULLET_LIFETIME });
    }

    function shoot() {
      if (targetsHit >= TOTAL_TARGETS) return;
      createBullet();
      flashCrosshair();
    }

    function updateBullets(delta) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bulletData = bullets[i];
        bulletData.life -= delta;
        bulletData.mesh.position.addScaledVector(bulletData.velocity, delta);

        if (bulletData.life <= 0) {
          scene.remove(bulletData.mesh);
          bullets.splice(i, 1);
          continue;
        }

        let hitTarget = false;
        for (let j = targets.length - 1; j >= 0; j--) {
          const target = targets[j];
          if (target.userData.hit) continue;
          target.getWorldPosition(targetWorldPosition);
          const radius = target.userData.radius * target.scale.x;
          if (bulletData.mesh.position.distanceTo(targetWorldPosition) <= radius) {
            handleTargetHit(target);
            scene.remove(bulletData.mesh);
            bullets.splice(i, 1);
            hitTarget = true;
            break;
          }
        }

        if (hitTarget) {
          continue;
        }
      }
    }

    function updateTargets(delta) {
      camera.getWorldPosition(cameraWorldPosition);
      for (let i = targets.length - 1; i >= 0; i--) {
        const target = targets[i];
        if (!target.userData.hit) {
          target.lookAt(cameraWorldPosition);
          target.rotation.x = 0;
          target.rotation.z = 0;
          target.children.forEach((child, index) => {
            if (index === 0) child.rotation.z += delta;
            if (index === 1) child.rotation.z -= delta * 1.4;
            if (index === 2) {
              child.rotation.x += delta * 1.6;
              child.rotation.y += delta * 1.1;
            }
          });
        } else {
          target.userData.fade += delta;
          const scale = Math.max(0, 1 - target.userData.fade * 3);
          target.scale.setScalar(scale);
          if (scale <= 0.05) {
            scene.remove(target);
            targets.splice(i, 1);
          }
        }
      }
    }

    if (shootButton) {
      shootButton.addEventListener("click", (event) => {
        event.preventDefault();
        shoot();
      });
      shootButton.addEventListener("touchstart", (event) => {
        if (event.cancelable !== false) event.preventDefault();
        shoot();
      }, { passive: false });
    }

    document.addEventListener("mousedown", (event) => {
      if (event.button === 0 && !isMobile && !gyroActive && pointerLocked) {
        shoot();
      }
    });

    renderer.domElement.addEventListener("click", () => {
      if (gyroActive || isMobile) return;
      if (!pointerLocked) {
        renderer.domElement.requestPointerLock();
      }
    });

    document.addEventListener("pointerlockchange", () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
      renderer.domElement.style.cursor = pointerLocked ? "none" : (gyroActive ? "auto" : "grab");
    });

    renderer.domElement.addEventListener("touchstart", onTouchStartLook, { passive: false });
    renderer.domElement.addEventListener("touchmove", onTouchMoveLook, { passive: false });
    renderer.domElement.addEventListener("touchend", onTouchEndLook);
    renderer.domElement.addEventListener("touchcancel", onTouchEndLook);

    document.addEventListener("mousemove", (event) => {
      if (!pointerLocked || gyroActive) return;
      yaw -= event.movementX * POINTER_SENSITIVITY;
      pitch -= event.movementY * POINTER_SENSITIVITY;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      applyCameraRotation();
    });

    function handleResize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    handleResize();
    window.addEventListener("resize", handleResize);

    const clock = new THREE.Clock();
    const worldUp = new THREE.Vector3(0, 1, 0);
    const inputVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const displacement = new THREE.Vector3();

    let targetsHit = 0;
    updateScoreDisplay();
    createTargets();

    function updateMovement(delta) {
      const joystickX = Math.abs(moveJoystickData.x) > 0.01 ? moveJoystickData.x : 0;
      const joystickY = Math.abs(moveJoystickData.y) > 0.01 ? moveJoystickData.y : 0;

      inputVector.set(joystickX, 0, -joystickY);

      if (inputVector.x === 0 && inputVector.z === 0) return;

      if (inputVector.lengthSq() > 1) {
        inputVector.normalize();
      }

      forwardVector.set(0, 0, -1).applyQuaternion(camera.quaternion);
      forwardVector.y = 0;
      if (forwardVector.lengthSq() > 0.0001) {
        forwardVector.normalize();
      } else {
        forwardVector.set(0, 0, -1);
      }

      rightVector.crossVectors(forwardVector, worldUp);
      if (rightVector.lengthSq() > 0.0001) {
        rightVector.normalize();
      } else {
        rightVector.set(1, 0, 0);
      }

      displacement.copy(forwardVector).multiplyScalar(inputVector.z);
      displacement.addScaledVector(rightVector, inputVector.x);

      if (displacement.lengthSq() === 0) return;

      displacement.normalize().multiplyScalar(MOVE_SPEED * delta);
      camera.position.add(displacement);
      camera.position.y = 1.6;
    }

    renderer.setAnimationLoop(() => {
      const delta = clock.getDelta();
      if (gyroActive && gyroControls && isGyroAvailable) {
        gyroControls.update();
      }
      updateMovement(delta);
      updateBullets(delta);
      updateTargets(delta);
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
