<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark Background Demo</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.12em; text-transform: uppercase; z-index: 10; }
    #gyroPermission { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.78); color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; padding: 32px; z-index: 9; }
    #gyroPermission > div { max-width: 320px; }
    #gyroPermission button { margin-top: 20px; padding: 10px 28px; border: 1px solid rgba(255, 255, 255, 0.7); background: transparent; color: #fff; font-size: 0.82rem; letter-spacing: 0.12em; cursor: pointer; }
    #gyroPermission button:active { background: rgba(255, 255, 255, 0.1); }
    #scoreDisplay { position: fixed; top: 24px; left: 24px; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; font-size: 0.9rem; text-transform: uppercase; z-index: 8; pointer-events: none; transition: color 0.15s ease, text-shadow 0.15s ease; }
    #scoreDisplay.damage { color: #ff6f91; text-shadow: 0 0 12px rgba(255, 127, 159, 0.8); }
    #crosshair { position: fixed; top: 50%; left: 50%; width: 28px; height: 28px; transform: translate(-50%, -50%); pointer-events: none; z-index: 8; opacity: 0.7; }
    #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    #crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #crosshair .circle { position: absolute; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.4); top: 50%; left: 50%; transform: translate(-50%, -50%); }
    #crosshair.powered::before, #crosshair.powered::after { background: rgba(173, 235, 255, 0.9); box-shadow: 0 0 6px rgba(120, 210, 255, 0.8); }
    #crosshair.powered .circle { border-color: rgba(173, 235, 255, 0.9); box-shadow: 0 0 8px rgba(120, 210, 255, 0.75); }
    #crosshair.flash { animation: crosshairFlash 0.2s ease-out; }
    @keyframes crosshairFlash { 0% { transform: translate(-50%, -50%) scale(1.3); } 100% { transform: translate(-50%, -50%) scale(1); } }
    #startButton {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 18px 48px;
      border: 1px solid rgba(166, 213, 255, 0.7);
      background: rgba(20, 32, 70, 0.86);
      color: #e8f4ff;
      font-family: system-ui, sans-serif;
      letter-spacing: 0.22em;
      font-size: 0.9rem;
      text-transform: uppercase;
      z-index: 12;
      cursor: pointer;
      box-shadow: 0 0 24px rgba(110, 202, 255, 0.45), inset 0 0 12px rgba(36, 82, 160, 0.6);
      backdrop-filter: blur(4px);
      transition: transform 0.15s ease;
    }
    #startButton:active {
      transform: translate(-50%, -50%) scale(0.97);
    }
    #startButton.hidden {
      display: none;
    }
    #shootButton { position: fixed; bottom: 24px; left: 24px; width: 112px; height: 112px; border-radius: 50%; border: 1px solid rgba(132, 182, 255, 0.6); display: flex; align-items: center; justify-content: center; font-family: system-ui, sans-serif; font-size: 0.78rem; letter-spacing: 0.18em; color: #dff4ff; background: radial-gradient(circle at 30% 30%, rgba(86, 149, 255, 0.55), rgba(18, 37, 82, 0.85) 58%, rgba(7, 12, 28, 0.95)); box-shadow: 0 0 22px rgba(64, 128, 255, 0.42), inset 0 0 18px rgba(22, 90, 150, 0.45); z-index: 7; cursor: pointer; user-select: none; touch-action: none; backdrop-filter: blur(2px); }
    #shootButton::before { content: ''; position: absolute; inset: 8px; border-radius: 50%; border: 1px solid rgba(166, 213, 255, 0.35); box-shadow: inset 0 0 20px rgba(117, 182, 255, 0.35), 0 0 14px rgba(48, 120, 220, 0.35); background: radial-gradient(circle, rgba(72, 140, 255, 0.18), rgba(9, 24, 49, 0.0) 62%); }
    #shootButton::after { content: ''; position: absolute; inset: 0; border-radius: 50%; box-shadow: 0 0 28px rgba(60, 140, 255, 0.4); opacity: 0.7; }
    #shootButton span { position: relative; z-index: 1; margin-top: 28px; opacity: 0.92; text-shadow: 0 0 8px rgba(112, 208, 255, 0.8); }
    #shootButton:active { transform: scale(0.97); box-shadow: 0 0 14px rgba(90, 160, 255, 0.48), inset 0 0 22px rgba(18, 98, 190, 0.6); }
    .shoot-crosshair { position: absolute; width: 58px; height: 58px; top: 42%; left: 50%; transform: translate(-50%, -50%); opacity: 0.9; filter: drop-shadow(0 0 12px rgba(124, 210, 255, 0.65)); }
    .shoot-crosshair::before, .shoot-crosshair::after { content: ''; position: absolute; background: linear-gradient(90deg, rgba(120, 210, 255, 0), rgba(120, 210, 255, 0.95), rgba(120, 210, 255, 0)); }
    .shoot-crosshair::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
    .shoot-crosshair::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #mobileUI { position: fixed; bottom: 24px; right: 24px; display: none; z-index: 6; pointer-events: none; }
    #moveJoystick { width: 128px; height: 128px; border-radius: 50%; border: 1px solid rgba(120, 182, 255, 0.45); background: radial-gradient(circle, rgba(60, 102, 166, 0.45), rgba(16, 31, 60, 0.82) 65%, rgba(5, 12, 26, 0.95)); position: relative; pointer-events: auto; touch-action: none; box-shadow: 0 0 24px rgba(54, 122, 220, 0.4), inset 0 0 16px rgba(32, 72, 140, 0.35); backdrop-filter: blur(2px); }
    #moveJoystick::before { content: ''; position: absolute; inset: 18px; border-radius: 50%; border: 1px solid rgba(156, 210, 255, 0.25); box-shadow: inset 0 0 16px rgba(98, 171, 255, 0.35); background: radial-gradient(circle, rgba(94, 162, 255, 0.18), rgba(9, 20, 46, 0)); }
    #moveStick { position: absolute; width: 64px; height: 64px; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(134, 222, 255, 0.7), rgba(53, 128, 210, 0.6) 55%, rgba(7, 16, 36, 0.85)); border: 1px solid rgba(186, 236, 255, 0.85); top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s ease; box-shadow: 0 0 16px rgba(110, 212, 255, 0.6), inset 0 0 12px rgba(42, 108, 188, 0.55); }
    #moveStick::before, #moveStick::after { content: ''; position: absolute; background: linear-gradient(90deg, rgba(162, 232, 255, 0), rgba(162, 232, 255, 0.9), rgba(162, 232, 255, 0)); }
    #moveStick::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
    #moveStick::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="gyroPermission">
    <div>
      <p>Enable gyroscope aim for mobile.</p>
      <button id="requestGyro">Enable Gyro</button>
    </div>
  </div>
  <div id="scoreDisplay">Press START to begin</div>
  <button id="startButton">START</button>
  <div id="crosshair"><div class="circle"></div></div>
  <div id="shootButton">
    <div class="shoot-crosshair"></div>
    <span>SHOOT</span>
  </div>
  <div id="mobileUI">
    <div id="moveJoystick">
      <div id="moveStick"></div>
    </div>
  </div>
  <script type="module">
import * as THREE from "three";
import { SparkRenderer, SplatMesh } from "@sparkjsdev/spark";

const SPZ_URL = "https://space-gimu.s3.ap-northeast-1.amazonaws.com/space.spz";
const MOVE_SPEED = 3.8;
const MOBILE_MOVE_SPEED = 6.0;
const POINTER_SENSITIVITY = 0.002;
const PITCH_LIMIT = Math.PI / 2 - 0.01;
const BULLET_SPEED = 40;
const BULLET_LIFETIME = 1.6;
const SHOOT_COOLDOWN = 0.18;
const PLAYER_MAX_HEALTH = 5;
const PLAYER_HIT_RADIUS = 1.3;
const BOSS_MAX_HEALTH = 12;
const BOSS_WEAK_POINT_RADIUS = 1.8;
const BOSS_ATTACK_COOLDOWN_MIN = 1.2;
const BOSS_ATTACK_COOLDOWN_MAX = 2.4;
const BOSS_MOVE_INTERVAL = 2.8;
const BOSS_ORBIT_RADIUS_MIN = 26;
const BOSS_ORBIT_RADIUS_MAX = 42;
const BOSS_MODEL_SCALE = 0.9;
const BOSS_BASE_HEIGHT = 6.5;
const BOSS_HIT_EFFECT_DURATION = 0.6;
const BOSS_HIT_SPARK_COUNT = 120;
const BOSS_HIT_ARC_COUNT = 15;
const BOSS_HIT_RING_MAX_SCALE = 7.0;
const BOSS_HIT_PARTICLE_COUNT = 160;
const BOSS_TAUNT_DURATION = 3.0;
const BOSS_TAUNT_COOLDOWN = 4.0;
const BOSS_TAUNT_BURST_DELAY = 0.3;
const BOSS_TAUNT_BURST_PROJECTILES = 20;

const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.domElement.style.cursor = "grab";
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x040212, 18, 160);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";
camera.position.set(0, 1.6, 3.5);
camera.lookAt(new THREE.Vector3(0, 1.6, -24));

scene.add(new THREE.AmbientLight(0x88aaff, 0.45));
const rimLight = new THREE.DirectionalLight(0xcbd5ff, 0.7);
rimLight.position.set(-6, 8, 12);
scene.add(rimLight);
const fillLight = new THREE.PointLight(0x2233ff, 1.6, 120);
fillLight.position.set(0, 12, -24);
scene.add(fillLight);

const cameraEuler = new THREE.Euler(0, 0, 0, "YXZ");
cameraEuler.setFromQuaternion(camera.quaternion);
let pitch = cameraEuler.x;
let yaw = cameraEuler.y;

const isMobile = /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
const gyroPermissionEl = document.getElementById("gyroPermission");
const requestGyroButton = document.getElementById("requestGyro");
const mobileUI = document.getElementById("mobileUI");
const moveJoystick = document.getElementById("moveJoystick");
const moveStick = document.getElementById("moveStick");
const startButton = document.getElementById("startButton");
const shootButton = document.getElementById("shootButton");
const scoreDisplay = document.getElementById("scoreDisplay");
const crosshair = document.getElementById("crosshair");

let gyroControls = null;
let gyroActive = false;
let isGyroAvailable = false;
let pointerLocked = false;
let moveJoystickData = { x: 0, y: 0 };
let touchLookActive = false;
let lastTouchX = 0;
let lastTouchY = 0;

const bullets = [];
const bossAttacks = [];
const bossTauntParticles = [];
const bossDeathPieces = [];
const bossHitEffects = [];
let playerHealth = PLAYER_MAX_HEALTH;
let bossHealth = BOSS_MAX_HEALTH;
let shootCooldownTimer = 0;
let attackCooldownTimer = THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
let bossMoveTimer = 0;
let bossTime = 0;
let bossHitReaction = 0;
let bossAttackPattern = 0;
let bossStunned = false;
let bossStunTimer = 0;
let bossStunDuration = 0.8;
let bossFlashTimer = 0;
let bossFlashDuration = 0.6;
let gameStarted = false;
let gameActive = false;
let victoryAchieved = false;
let defeat = false;
let isBossDying = false;
let bossTaunting = false;
let bossTauntTimer = 0;
let bossTauntPhase = 0;
let bossTauntPulseTimer = 0;

let boss = null;
let bossCore = null;
let bossWeakPoint = null;
let bossFloatingCrystals = [];
let bossEnergyRings = [];
let bossShoulders = [];
let bossWings = [];
let bossWeakPointGlow = 0;
const bossTargetOffset = new THREE.Vector3(0, 0, -32);
const bossTargetPosition = new THREE.Vector3(
  camera.position.x + bossTargetOffset.x,
  BOSS_BASE_HEIGHT,
  camera.position.z + bossTargetOffset.z
);

const clock = new THREE.Clock();
const worldUp = new THREE.Vector3(0, 1, 0);
const inputVector = new THREE.Vector3();
const forwardVector = new THREE.Vector3();
const rightVector = new THREE.Vector3();
const displacement = new THREE.Vector3();
const bulletStartPosition = new THREE.Vector3();
const bulletDirection = new THREE.Vector3();
const tmpVecA = new THREE.Vector3();
const tmpVecB = new THREE.Vector3();

function updateBossTargetPositionFromPlayer() {
  bossTargetPosition.set(
    camera.position.x + bossTargetOffset.x,
    BOSS_BASE_HEIGHT,
    camera.position.z + bossTargetOffset.z
  );
}

function setBossTargetAroundPlayer() {
  const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
  const radius = THREE.MathUtils.randFloat(BOSS_ORBIT_RADIUS_MIN, BOSS_ORBIT_RADIUS_MAX);
  bossTargetOffset.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
  updateBossTargetPositionFromPlayer();
}
function hideStartButton() {
  if (!startButton) return;
  startButton.classList.add("hidden");
}

function showStartButton(label) {
  if (!startButton) return;
  startButton.textContent = label || "START";
  startButton.classList.remove("hidden");
  if (document.pointerLockElement === renderer.domElement) {
    document.exitPointerLock();
  }
  pointerLocked = false;
  renderer.domElement.style.cursor = gyroActive ? "auto" : "grab";
}

function updateHud() {
  if (!scoreDisplay) return;
  if (defeat) {
    scoreDisplay.textContent = "GAME OVER";
    return;
  }
  if (victoryAchieved) {
    scoreDisplay.textContent = "Victory! Press START to battle again";
    return;
  }
  if (!gameStarted) {
    scoreDisplay.textContent = "Press START to begin";
  } else {
    scoreDisplay.textContent = "Player HP: " + playerHealth + "/" + PLAYER_MAX_HEALTH + "  Boss HP: " + bossHealth + "/" + BOSS_MAX_HEALTH;
  }
}

function setScoreDamageFlash() {
  if (!scoreDisplay) return;
  scoreDisplay.classList.add("damage");
  setTimeout(() => scoreDisplay.classList.remove("damage"), 160);
}


function createBoss() {
  bossFloatingCrystals = [];
  bossEnergyRings = [];
  bossShoulders = [];
  bossWings = [];
  bossWeakPointGlow = 0;

  const group = new THREE.Group();

  const bodyGroup = new THREE.Group();

  const outerBody = new THREE.Mesh(
    new THREE.OctahedronGeometry(7, 0),
    new THREE.MeshStandardMaterial({
      color: 0x0099ff,
      metalness: 0.3,
      roughness: 0.1,
      transparent: true,
      opacity: 0.7,
      emissive: 0x0066ff,
      emissiveIntensity: 0.2
    })
  );
  outerBody.scale.y = 1.8;
  bodyGroup.add(outerBody);

  const innerBody = new THREE.Mesh(
    new THREE.OctahedronGeometry(5, 0),
    new THREE.MeshStandardMaterial({
      color: 0x00ccff,
      metalness: 0.7,
      roughness: 0.1,
      emissive: 0x0099ff,
      emissiveIntensity: 0.4
    })
  );
  innerBody.scale.y = 1.5;
  innerBody.castShadow = true;
  bodyGroup.add(innerBody);

  group.add(bodyGroup);

  const coreGroup = new THREE.Group();

  const coreMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x00ffff,
    emissiveIntensity: 2,
    metalness: 0.5,
    roughness: 0
  });
  bossCore = new THREE.Mesh(new THREE.IcosahedronGeometry(3, 1), coreMaterial);
  coreGroup.add(bossCore);

  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const miniCrystal = new THREE.Mesh(
      new THREE.TetrahedronGeometry(0.8, 0),
      coreMaterial.clone()
    );
    miniCrystal.position.set(
      Math.cos(angle) * 4,
      Math.sin(angle * 1.2) * 2.4,
      Math.sin(angle) * 4
    );
    bossFloatingCrystals.push(miniCrystal);
    coreGroup.add(miniCrystal);
  }

  group.add(coreGroup);

  for (let i = 0; i < 3; i++) {
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(8 + i * 2, 0.3, 8, 32),
      new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00ffff,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.6
      })
    );
    ring.rotation.x = Math.PI / 2;
    ring.position.y = (i - 1) * 3;
    bossEnergyRings.push(ring);
    group.add(ring);
  }

  for (const side of [-1, 1]) {
    const shoulderGroup = new THREE.Group();

    const shoulderMaterial = new THREE.MeshStandardMaterial({
      color: 0x00aaff,
      metalness: 0.8,
      roughness: 0.2,
      emissive: 0x0066ff,
      emissiveIntensity: 0.3
    });
    const shoulder = new THREE.Mesh(new THREE.OctahedronGeometry(4, 0), shoulderMaterial);
    shoulder.rotation.z = side * Math.PI / 6;
    shoulderGroup.add(shoulder);

    for (let j = 0; j < 3; j++) {
      const decor = new THREE.Mesh(new THREE.TetrahedronGeometry(1.5, 0), shoulderMaterial.clone());
      decor.position.set(
        side * 2 + Math.random() * 2 - 1,
        j * 2 - 2,
        Math.random() * 2 - 1
      );
      shoulderGroup.add(decor);
    }

    const cannonGroup = new THREE.Group();
    const cannonMaterial = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 1
    });
    const cannonCore = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), cannonMaterial);
    cannonGroup.add(cannonCore);

    for (let k = 0; k < 3; k++) {
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(2 + k * 0.5, 0.2, 8, 16),
        new THREE.MeshStandardMaterial({
          color: 0xff00ff,
          emissive: 0xff00ff,
          emissiveIntensity: 0.5
        })
      );
      ring.position.y = -k;
      cannonGroup.add(ring);
    }

    cannonGroup.position.y = -5;
    shoulderGroup.add(cannonGroup);

    const shoulderLight = new THREE.PointLight(0x00aaff, 2, 10);
    shoulderLight.position.set(0, 0, 0);
    shoulderGroup.add(shoulderLight);

    shoulderGroup.position.x = side * 12;
    shoulderGroup.position.y = 5;

    bossShoulders.push({
      group: shoulderGroup,
      cannon: cannonCore,
      phase: side === -1 ? 0 : Math.PI
    });
    group.add(shoulderGroup);
  }

  for (const side of [-1, 1]) {
    const wingGroup = new THREE.Group();

    for (let j = 0; j < 5; j++) {
      const wingMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00ffff,
        emissiveIntensity: 1.2,
        transparent: true,
        opacity: 0.8 - j * 0.1
      });
      const wingPart = new THREE.Mesh(new THREE.BoxGeometry(0.8, 10 - j * 1.5, 0.2), wingMaterial);
      wingPart.position.x = side * (j + 1) * 2.5;
      wingPart.position.y = -j * 1.5;
      wingPart.rotation.z = side * (Math.PI / 8 + j * 0.05);
      wingGroup.add(wingPart);

      const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1 - j * 0.15, 0), wingMaterial.clone());
      crystal.position.copy(wingPart.position);
      crystal.position.y += 2;
      wingGroup.add(crystal);
    }

    const wingGlow = new THREE.PointLight(0x00ffff, 3, 15);
    wingGlow.position.set(side * 8, 0, 0);
    wingGroup.add(wingGlow);

    wingGroup.position.x = side * 10;
    wingGroup.position.y = 5;
    wingGroup.position.z = -4;

    bossWings.push({ group: wingGroup, phase: side === -1 ? 0 : Math.PI });
    group.add(wingGroup);
  }

  const headGroup = new THREE.Group();
  const headMaterial = new THREE.MeshStandardMaterial({
    color: 0x0099ff,
    metalness: 0.9,
    roughness: 0.1,
    emissive: 0x0066ff,
    emissiveIntensity: 0.3
  });
  const head = new THREE.Mesh(new THREE.ConeGeometry(4, 6, 6), headMaterial);
  head.rotation.y = Math.PI / 6;
  headGroup.add(head);

  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.8, 3, 4), headMaterial.clone());
    spike.position.set(Math.cos(angle) * 3, 2, Math.sin(angle) * 3);
    spike.rotation.z = angle * 0.3;
    headGroup.add(spike);
  }

  headGroup.position.y = 12;
  group.add(headGroup);

  for (const side of [-1, 1]) {
    const eyeGroup = new THREE.Group();

    const eye = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    eyeGroup.add(eye);

    const eyeGlow = new THREE.Mesh(
      new THREE.SphereGeometry(1.8, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 })
    );
    eyeGroup.add(eyeGlow);

    const eyeLight = new THREE.PointLight(0xffffff, 5, 15);
    eyeGroup.add(eyeLight);

    eyeGroup.position.set(side * 2.5, 12, 2);
    group.add(eyeGroup);
  }

  const weakPointGroup = new THREE.Group();

  bossWeakPoint = new THREE.Mesh(
    new THREE.OctahedronGeometry(2, 1),
    new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 2,
      metalness: 0.5,
      roughness: 0
    })
  );
  weakPointGroup.add(bossWeakPoint);

  const weakPointLight = new THREE.PointLight(0xff0000, 10, 25);
  weakPointGroup.add(weakPointLight);

  weakPointGroup.position.set(0, 3, 5);
  group.add(weakPointGroup);

  const particleCount = 200;
  const particlesGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i++) {
    const radius = 15 + Math.random() * 5;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const index = i * 3;
    positions[index] = radius * Math.sin(phi) * Math.cos(theta);
    positions[index + 1] = radius * Math.sin(phi) * Math.sin(theta);
    positions[index + 2] = radius * Math.cos(phi);
  }
  particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  const particles = new THREE.Points(
    particlesGeometry,
    new THREE.PointsMaterial({ color: 0x00ffff, size: 0.3, transparent: true, opacity: 0.8 })
  );
  group.add(particles);

  group.position.copy(bossTargetPosition);
  group.scale.setScalar(BOSS_MODEL_SCALE);
  return group;
}

function initializeBoss() {
  updateBossTargetPositionFromPlayer();
  if (boss) {
    scene.remove(boss);
  }
  boss = createBoss();
  scene.add(boss);
}

function registerBossAttack(mesh, velocity, options) {
  options = options || {};
  const velocityDir = velocity.clone();
  const spawnOffset = options.spawnOffset === undefined ? 0.2 : options.spawnOffset;
  if (velocityDir.lengthSq() > 0) {
    velocityDir.normalize();
  }
  if (spawnOffset !== 0) {
    mesh.position.addScaledVector(velocityDir, spawnOffset);
  }
  scene.add(mesh);
  const attackData = {
    mesh,
    velocity,
    life: options.life === undefined ? 4 : options.life,
    spin: options.spin || new THREE.Vector3(),
    damage: options.damage === undefined ? 1 : options.damage,
    homing: options.homing || false,
    alignToVelocity: !!options.alignToVelocity,
    speedDamping: options.speedDamping || 0,
    onUpdate: typeof options.onUpdate === "function" ? options.onUpdate : null,
    cleanup: typeof options.cleanup === "function" ? options.cleanup : null
  };
  if (options.extra !== undefined) {
    attackData.extra = options.extra;
  }
  bossAttacks.push(attackData);
  return attackData;
}

function clearBossAttacks() {
  for (let i = bossAttacks.length - 1; i >= 0; i--) {
    scene.remove(bossAttacks[i].mesh);
  }
  bossAttacks.length = 0;
}

function clearBossDeathPieces() {
  for (let i = bossDeathPieces.length - 1; i >= 0; i--) {
    scene.remove(bossDeathPieces[i].mesh);
  }
  bossDeathPieces.length = 0;
  isBossDying = false;
}

function clearBossHitEffects() {
  for (let i = bossHitEffects.length - 1; i >= 0; i--) {
    const effect = bossHitEffects[i];
    if (effect.ring) scene.remove(effect.ring);
    if (effect.backRing) scene.remove(effect.backRing);
    if (effect.glow) scene.remove(effect.glow);
    if (effect.core) scene.remove(effect.core);
    if (effect.light) scene.remove(effect.light);
    if (effect.sparks) {
      effect.sparks.forEach((spark) => {
        if (spark.mesh) scene.remove(spark.mesh);
      });
    }
    if (effect.arcs) {
      effect.arcs.forEach((arcData) => {
        if (arcData.line) scene.remove(arcData.line);
      });
    }
    if (effect.particles && effect.particles.points) {
      scene.remove(effect.particles.points);
    }
  }
  bossHitEffects.length = 0;
}

function restoreBossOriginalColors() {
  if (!boss) return;
  
  boss.traverse((child) => {
    if (child.isMesh && child.material && child !== bossWeakPoint) {
      const material = child.material;
      
      // ボスの各パーツの元の色を明示的に設定
      if (child.geometry instanceof THREE.OctahedronGeometry) {
        if (material.opacity === 0.7) {
          // 外殻
          material.color.set(0x0099ff);
          material.emissive.set(0x0066ff);
          material.emissiveIntensity = 0.2;
        } else {
          // 内殻・その他
          material.color.set(0x00ccff);
          material.emissive.set(0x0099ff);
          material.emissiveIntensity = 0.4;
        }
      } else if (child.geometry instanceof THREE.IcosahedronGeometry) {
        // コア
        material.color.set(0xffffff);
        material.emissive.set(0x00ffff);
        material.emissiveIntensity = 2;
      } else if (child.geometry instanceof THREE.TetrahedronGeometry) {
        // 肩部・装飾
        material.color.set(0x00aaff);
        material.emissive.set(0x0066ff);
        material.emissiveIntensity = 0.3;
      } else if (child.geometry instanceof THREE.ConeGeometry) {
        // 頭部
        material.color.set(0x0099ff);
        material.emissive.set(0x0066ff);
        material.emissiveIntensity = 0.3;
      } else if (child.geometry instanceof THREE.SphereGeometry) {
        // キャノン・目
        if (material.emissiveIntensity === 1) {
          material.color.set(0xff00ff);
          material.emissive.set(0xff00ff);
          material.emissiveIntensity = 1;
        } else {
          material.color.set(0xffffff);
        }
      } else if (child.geometry instanceof THREE.BoxGeometry) {
        // ウィング
        material.color.set(0x00ffff);
        material.emissive.set(0x00ffff);
        material.emissiveIntensity = 1.2;
      } else if (child.geometry instanceof THREE.TorusGeometry) {
        // エネルギーリング
        material.color.set(0x00ffff);
        material.emissive.set(0x00ffff);
        material.emissiveIntensity = 1;
      }
      
      // userDataをクリア
      if (material.userData) {
        delete material.userData.originalEmissive;
        delete material.userData.originalEmissiveIntensity;
        delete material.userData.originalColor;
      }
    }
  });
}

function flashBoss() {
  if (!boss || bossTaunting) return; // 挑発中は点滅しない
  
  // 複数回の点滅エフェクト
  const flashSequence = [
    { delay: 0, intensity: 0.8, duration: 100 },
    { delay: 150, intensity: 0.6, duration: 100 },
    { delay: 300, intensity: 0.4, duration: 100 },
    { delay: 450, intensity: 0.2, duration: 100 }
  ];
  
  flashSequence.forEach((flash, index) => {
    setTimeout(() => {
      if (!boss) return;
      
      const flashColor = new THREE.Color(0xff0000);
      const flashEmissive = new THREE.Color(0xff0000);
      
      boss.traverse((child) => {
        if (child.isMesh && child !== bossWeakPoint) {
          const material = child.material;
          if (!material.userData) material.userData = {};
          if (!material.userData.originalColor) {
            material.userData.originalColor = material.color.clone();
          }
          if (material.emissive && !material.userData.originalEmissive) {
            material.userData.originalEmissive = material.emissive.clone();
          }
          
          // より強い赤色で点滅
          material.color.lerp(flashColor, flash.intensity);
          if (material.emissive) {
            material.emissive.lerp(flashEmissive, flash.intensity * 1.5);
          }
          
          setTimeout(() => {
            if (!boss) return;
            restoreBossOriginalColors();
          }, flash.duration);
        }
      });
    }, flash.delay);
  });
}

function spawnBossHitEffect(worldPosition) {
  const center = worldPosition.clone();
  const bossReference = boss; // ボスの参照を保存

  const ring = new THREE.Mesh(
    new THREE.RingGeometry(1.5, 3.5, 72, 1),
    new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.9,
      blending: THREE.NormalBlending,
      side: THREE.DoubleSide,
      depthWrite: true
    })
  );
  ring.position.copy(center);
  ring.lookAt(camera.position);
  scene.add(ring);

  const backRing = ring.clone();
  backRing.material = ring.material.clone();
  backRing.material.opacity = 0.6;
  scene.add(backRing);

  const glow = new THREE.Mesh(
    new THREE.SphereGeometry(1.2, 28, 28),
    new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      blending: THREE.NormalBlending,
      depthWrite: true
    })
  );
  glow.position.copy(center);
  scene.add(glow);

  const core = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.7, 2),
    new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 1.0,
      blending: THREE.NormalBlending,
      depthWrite: true
    })
  );
  core.position.copy(center);
  scene.add(core);

  const light = new THREE.PointLight(0xffff00, 25, 80);
  light.position.copy(center);
  scene.add(light);

  const sparks = [];
  const sparkPalette = [0xffff00, 0xff8800, 0xff4400, 0xff0044, 0x00ffff, 0xffffff];
  for (let i = 0; i < BOSS_HIT_SPARK_COUNT; i++) {
    const spark = new THREE.Mesh(
      new THREE.ConeGeometry(0.25, 1.8, 18),
      new THREE.MeshBasicMaterial({
        color: sparkPalette[Math.floor(Math.random() * sparkPalette.length)],
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      })
    );
    spark.position.copy(center);
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(2.0),
      THREE.MathUtils.randFloat(0.3, 2.0),
      THREE.MathUtils.randFloatSpread(2.0)
    ).normalize();
    const speed = THREE.MathUtils.randFloat(15, 35);
    const velocity = dir.multiplyScalar(speed);
    spark.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone());
    scene.add(spark);
    sparks.push({
      mesh: spark,
      velocity,
      rotationAxis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(),
      rotationSpeed: THREE.MathUtils.randFloat(-10, 10)
    });
  }

  const arcs = [];
  for (let i = 0; i < BOSS_HIT_ARC_COUNT; i++) {
    const segmentCount = THREE.MathUtils.randInt(4, 6);
    const basePoints = [];
    let current = new THREE.Vector3();
    basePoints.push(current.clone());
    const orientation = new THREE.Quaternion().setFromEuler(new THREE.Euler(
      THREE.MathUtils.randFloat(0, Math.PI * 2),
      THREE.MathUtils.randFloat(0, Math.PI * 2),
      THREE.MathUtils.randFloat(0, Math.PI * 2)
    ));
    for (let s = 0; s < segmentCount; s++) {
      const step = new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(0.9),
        THREE.MathUtils.randFloatSpread(0.9),
        THREE.MathUtils.randFloatSpread(0.9)
      )
        .normalize()
        .multiplyScalar(THREE.MathUtils.randFloat(0.8, 2.2));
      current = current.clone().add(step);
      basePoints.push(current.clone());
    }
    const rotated = basePoints.map((pt) => pt.clone().applyQuaternion(orientation));
    const geometry = new THREE.BufferGeometry().setFromPoints(rotated);
    const material = new THREE.LineBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 1.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      linewidth: 3
    });
    const arc = new THREE.Line(geometry, material);
    arc.position.copy(center);
    scene.add(arc);
    arcs.push({ line: arc, basePoints: rotated, material });
  }

  const particlePositions = new Float32Array(BOSS_HIT_PARTICLE_COUNT * 3);
  const particleVelocities = [];
  for (let i = 0; i < BOSS_HIT_PARTICLE_COUNT; i++) {
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(1.4),
      THREE.MathUtils.randFloatSpread(1.4),
      THREE.MathUtils.randFloatSpread(1.4)
    ).normalize();
    const speed = THREE.MathUtils.randFloat(9, 20);
    particleVelocities.push(dir.multiplyScalar(speed));
    particlePositions[i * 3 + 0] = center.x;
    particlePositions[i * 3 + 1] = center.y;
    particlePositions[i * 3 + 2] = center.z;
  }
  const particlesGeometry = new THREE.BufferGeometry();
  particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
  const particlesMaterial = new THREE.PointsMaterial({
    color: 0x00ffff,
    size: 0.3,
    transparent: true,
    opacity: 0.9,
    blending: THREE.NormalBlending,
    depthWrite: true
  });
  const particles = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particles);

  bossHitEffects.push({
    center,
    ring,
    backRing,
    glow,
    core,
    light,
    sparks,
    arcs,
    particles: {
      points: particles,
      geometry: particlesGeometry,
      material: particlesMaterial,
      velocities: particleVelocities,
      positions: particlePositions
    },
    life: BOSS_HIT_EFFECT_DURATION,
    maxLife: BOSS_HIT_EFFECT_DURATION,
    bossReference,
    offsetFromBoss: worldPosition.clone().sub(bossReference ? bossReference.position : new THREE.Vector3())
  });
}

function updateBossHitEffects(delta) {
  for (let i = bossHitEffects.length - 1; i >= 0; i--) {
    const effect = bossHitEffects[i];
    effect.life -= delta;
    const lifeRatio = Math.max(effect.life, 0) / effect.maxLife;
    const progress = 1 - lifeRatio;

    // ボスが停止中の場合のみ位置に追従
    if (effect.bossReference && effect.bossReference.position && bossStunned) {
      const newCenter = effect.bossReference.position.clone().add(effect.offsetFromBoss);
      effect.center.copy(newCenter);
      
      // エフェクトの位置を更新
      if (effect.ring) effect.ring.position.copy(newCenter);
      if (effect.backRing) effect.backRing.position.copy(newCenter);
      if (effect.glow) effect.glow.position.copy(newCenter);
      if (effect.core) effect.core.position.copy(newCenter);
      if (effect.light) effect.light.position.copy(newCenter);
      
      // スパークの位置は移動するので、初期位置のみ更新
      // スパークは既に移動しているので、位置をリセットしない
      
      // アークの位置を更新
      if (effect.arcs) {
        effect.arcs.forEach((arcData) => {
          if (arcData.line) {
            arcData.line.position.copy(newCenter);
          }
        });
      }
      
      // パーティクルの位置は移動するので、初期位置のみ更新
      // パーティクルは既に移動しているので、位置をリセットしない
    }

    if (effect.ring) {
      const ringScale = 1 + progress * (BOSS_HIT_RING_MAX_SCALE - 1);
      effect.ring.scale.setScalar(ringScale);
      effect.ring.lookAt(camera.position);
      if (effect.ring.material) {
        effect.ring.material.opacity = THREE.MathUtils.lerp(0.9, 0, Math.pow(progress, 0.9));
      }
    }

    if (effect.backRing) {
      const ringScale = 1 + progress * (BOSS_HIT_RING_MAX_SCALE * 1.2 - 1);
      effect.backRing.scale.setScalar(ringScale);
      effect.backRing.lookAt(camera.position);
      if (effect.backRing.material) {
        effect.backRing.material.opacity = THREE.MathUtils.lerp(0.6, 0, progress);
      }
    }

    if (effect.glow) {
      const glowScale = 1.2 + progress * 4.0;
      effect.glow.scale.setScalar(glowScale);
      if (effect.glow.material) {
        effect.glow.material.opacity = THREE.MathUtils.lerp(0.9, 0, Math.pow(progress, 1.1));
      }
    }

    if (effect.core) {
      const coreScale = 0.7 + Math.sin(progress * Math.PI * 2) * 0.3 + progress * 1.2;
      effect.core.scale.setScalar(coreScale);
      effect.core.rotation.x += delta * 6;
      effect.core.rotation.y += delta * 7;
      effect.core.material.opacity = THREE.MathUtils.lerp(1.0, 0, progress);
    }

    if (effect.light) {
      effect.light.intensity = THREE.MathUtils.lerp(25, 0, progress);
      effect.light.distance = THREE.MathUtils.lerp(80, 20, progress);
    }

    if (effect.sparks) {
      effect.sparks.forEach((sparkData) => {
        if (!sparkData.mesh) return;
        sparkData.velocity.multiplyScalar(1 - delta * 0.3);
        sparkData.velocity.y -= delta * 8;
        sparkData.mesh.position.addScaledVector(sparkData.velocity, delta);
        sparkData.mesh.rotateOnAxis(sparkData.rotationAxis, sparkData.rotationSpeed * delta);
        const mat = sparkData.mesh.material;
        if (mat) {
          mat.opacity = Math.max(0, 1 - progress * 0.8);
        }
        if (sparkData.mesh.position.distanceToSquared(effect.center) > 1600) {
          scene.remove(sparkData.mesh);
          sparkData.mesh = null;
        }
      });
    }

    if (effect.arcs) {
      effect.arcs.forEach((arcData) => {
        if (!arcData.line) return;
        const positions = arcData.line.geometry.attributes.position;
        for (let p = 0; p < arcData.basePoints.length; p++) {
          const base = arcData.basePoints[p];
          const jitter = (1 - progress) * 0.45;
          positions.setXYZ(
            p,
            base.x + THREE.MathUtils.randFloatSpread(jitter),
            base.y + THREE.MathUtils.randFloatSpread(jitter),
            base.z + THREE.MathUtils.randFloatSpread(jitter)
          );
        }
        positions.needsUpdate = true;
        if (arcData.material) {
          arcData.material.opacity = THREE.MathUtils.lerp(1.0, 0, progress);
        }
      });
    }

    if (effect.particles) {
      const positions = effect.particles.positions;
      const velocities = effect.particles.velocities;
      for (let p = 0; p < velocities.length; p++) {
        const vel = velocities[p];
        vel.multiplyScalar(1 - delta * 0.4);
        vel.y -= delta * 7;
        const idx = p * 3;
        positions[idx + 0] += vel.x * delta;
        positions[idx + 1] += vel.y * delta;
        positions[idx + 2] += vel.z * delta;
      }
      effect.particles.geometry.attributes.position.needsUpdate = true;
      if (effect.particles.material) {
        effect.particles.material.opacity = Math.max(0, 0.9 - progress * 1.3);
      }
    }

    if (effect.life <= 0) {
      if (effect.ring) scene.remove(effect.ring);
      if (effect.backRing) scene.remove(effect.backRing);
      if (effect.glow) scene.remove(effect.glow);
      if (effect.core) scene.remove(effect.core);
      if (effect.light) scene.remove(effect.light);
      if (effect.sparks) {
        effect.sparks.forEach((sparkData) => {
          if (sparkData.mesh) scene.remove(sparkData.mesh);
        });
      }
      if (effect.arcs) {
        effect.arcs.forEach((arcData) => {
          if (arcData.line) scene.remove(arcData.line);
        });
      }
      if (effect.particles && effect.particles.points) {
        scene.remove(effect.particles.points);
      }
      bossHitEffects.splice(i, 1);
    }
  }
}

function startBossDeathSequence() {
  if (!boss) return;
  victoryAchieved = true;
  gameActive = false;
  gameStarted = false;
  isBossDying = true;
  showStartButton("RESTART");

  const origin = new THREE.Vector3();
  boss.getWorldPosition(origin);
  scene.remove(boss);
  boss = null;
  bossWeakPoint = null;
  bossCore = null;

  for (let i = 0; i < 36; i++) {
    const shard = new THREE.Mesh(
      new THREE.TetrahedronGeometry(THREE.MathUtils.randFloat(0.3, 0.8), 0),
      new THREE.MeshStandardMaterial({
        color: 0x7cd3ff,
        emissive: 0x4fe0ff,
        emissiveIntensity: 0.9,
        transparent: true,
        opacity: 1
      })
    );
    shard.position.copy(origin);
    shard.position.x += THREE.MathUtils.randFloatSpread(1.5);
    shard.position.y += THREE.MathUtils.randFloatSpread(1.5);
    shard.position.z += THREE.MathUtils.randFloatSpread(1.5);
    scene.add(shard);
    bossDeathPieces.push({
      mesh: shard,
      velocity: new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(14),
        THREE.MathUtils.randFloat(3, 16),
        THREE.MathUtils.randFloatSpread(14)
      ),
      angular: new THREE.Vector3(
        THREE.MathUtils.randFloat(-8, 8),
        THREE.MathUtils.randFloat(-8, 8),
        THREE.MathUtils.randFloat(-8, 8)
      ),
      life: 2.2
    });
  }

  const flash = new THREE.PointLight(0x88ccff, 90, 80);
  flash.position.copy(origin);
  scene.add(flash);
  setTimeout(() => scene.remove(flash), 400);
  updateHud();
}

function startBattle() {
  clearBossAttacks();
  clearBossDeathPieces();
  clearBossHitEffects();
  playerHealth = PLAYER_MAX_HEALTH;
  bossHealth = BOSS_MAX_HEALTH;
  shootCooldownTimer = 0;
  attackCooldownTimer = THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
  bossMoveTimer = 0;
  bossTime = 0;
  bossHitReaction = 0;
  bossAttackPattern = 0;
  bossStunned = false;
  bossStunTimer = 0;
  bossFlashTimer = 0;
  bossTaunting = false;
  bossTauntTimer = 0;
  bossTauntPhase = 0;
  bossTauntPulseTimer = 0;
  victoryAchieved = false;
  defeat = false;
  gameStarted = true;
  gameActive = true;
  hideStartButton();
  
  // ボスの色をリセット（前回のゲームの挑発状態をクリア）
  restoreBossOriginalColors();

  setBossTargetAroundPlayer();

  if (!boss) {
    initializeBoss();
  }
  if (boss) {
    boss.position.copy(bossTargetPosition);
    boss.rotation.set(0, 0, 0);
    tmpVecA.subVectors(camera.position, boss.position);
    boss.rotation.y = Math.atan2(tmpVecA.x, tmpVecA.z);
    boss.scale.set(1, 1, 1);
  }

  updateHud();
}

function applyPlayerDamage(amount) {
  if (victoryAchieved || defeat) return;
  playerHealth = Math.max(0, playerHealth - (amount || 1));
  setScoreDamageFlash();
  if (playerHealth <= 0) {
    defeat = true;
    gameActive = false;
    gameStarted = false;
    showStartButton("RESTART");
    clearBossAttacks();
  }
  updateHud();
}

function handleBossHit(worldPosition) {
  if (!gameActive || victoryAchieved || !bossWeakPoint || bossStunned) return;
  
  // ボスを停止状態にする
  bossStunned = true;
  bossStunTimer = bossStunDuration;
  bossFlashTimer = bossFlashDuration;
  
  bossHealth = Math.max(0, bossHealth - 1);
  bossHitReaction = 1;
  bossMoveTimer = 0;
  // 停止中は移動しないので、setBossTargetAroundPlayer()を呼ばない

  const flash = new THREE.PointLight(0xffff80, 26, 40);
  flash.position.copy(worldPosition);
  scene.add(flash);
  setTimeout(() => scene.remove(flash), 200);

  flashBoss();
  spawnBossHitEffect(worldPosition);
  updateHud();

  if (bossHealth <= 0) {
    startBossDeathSequence();
  }
}

function createBullet() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 12, 12),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
  );
  camera.getWorldPosition(bulletStartPosition);
  camera.getWorldDirection(bulletDirection);
  bulletDirection.normalize();
  bullet.position.copy(bulletStartPosition).addScaledVector(bulletDirection, 0.6);
  scene.add(bullet);
  bullets.push({ mesh: bullet, velocity: bulletDirection.clone().multiplyScalar(BULLET_SPEED), life: BULLET_LIFETIME });
}

function shoot() {
  if (!gameStarted || !gameActive || shootCooldownTimer > 0) {
    return;
  }
  shootCooldownTimer = SHOOT_COOLDOWN;
  createBullet();
  if (crosshair) {
    crosshair.classList.remove("flash");
    void crosshair.offsetWidth;
    crosshair.classList.add("flash");
  }
}
function updateBullets(delta) {
  if (bullets.length === 0) return;
  const weakPointPosition = new THREE.Vector3();
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bulletData = bullets[i];
    bulletData.life -= delta;
    bulletData.mesh.position.addScaledVector(bulletData.velocity, delta);
    if (bulletData.life <= 0) {
      scene.remove(bulletData.mesh);
      bullets.splice(i, 1);
      continue;
    }
    if (bossWeakPoint && gameActive && !victoryAchieved) {
      bossWeakPoint.getWorldPosition(weakPointPosition);
      if (bulletData.mesh.position.distanceTo(weakPointPosition) <= BOSS_WEAK_POINT_RADIUS) {
        handleBossHit(weakPointPosition.clone());
        scene.remove(bulletData.mesh);
        bullets.splice(i, 1);
      }
    }
  }
}

function updateBossAttacks(delta) {
  for (let i = bossAttacks.length - 1; i >= 0; i--) {
    const attack = bossAttacks[i];
    if (!attack) {
      continue;
    }
    attack.life -= delta;

    if (attack.homing && gameActive) {
      tmpVecA.copy(camera.position).sub(attack.mesh.position).normalize();
      const speed = attack.velocity.length();
      attack.velocity.lerp(tmpVecA.multiplyScalar(speed), delta * 0.9);
    }

    if (attack.speedDamping) {
      const damping = Math.max(0, 1 - attack.speedDamping * delta);
      attack.velocity.multiplyScalar(damping);
    }

    attack.mesh.position.addScaledVector(attack.velocity, delta);

    if (attack.alignToVelocity) {
      tmpVecB.copy(attack.velocity);
      if (tmpVecB.lengthSq() > 0.0001) {
        tmpVecB.normalize();
        tmpVecB.add(attack.mesh.position);
        attack.mesh.lookAt(tmpVecB);
      }
    }

    if (attack.onUpdate) {
      attack.onUpdate(attack, delta);
    }

    attack.mesh.rotation.x += attack.spin.x * delta;
    attack.mesh.rotation.y += attack.spin.y * delta;
    attack.mesh.rotation.z += attack.spin.z * delta;

    if (attack.life <= 0 || attack.mesh.position.distanceToSquared(camera.position) > 40000) {
      if (attack.cleanup) {
        attack.cleanup(attack);
      }
      scene.remove(attack.mesh);
      bossAttacks.splice(i, 1);
      continue;
    }

    if (!victoryAchieved && !defeat) {
      if (attack.mesh.position.distanceTo(camera.position) <= PLAYER_HIT_RADIUS) {
        if (attack.cleanup) {
          attack.cleanup(attack);
        }
        scene.remove(attack.mesh);
        bossAttacks.splice(i, 1);
        applyPlayerDamage(attack.damage);
        if (bossAttacks.length === 0) {
          break;
        }
        continue;
      }
    }
  }
}

function updateBossDeath(delta) {
  if (!isBossDying) return;
  for (let i = bossDeathPieces.length - 1; i >= 0; i--) {
    const piece = bossDeathPieces[i];
    piece.life -= delta;
    piece.mesh.position.addScaledVector(piece.velocity, delta);
    piece.velocity.y -= 9.8 * delta * 0.4;
    piece.mesh.rotation.x += piece.angular.x * delta;
    piece.mesh.rotation.y += piece.angular.y * delta;
    piece.mesh.rotation.z += piece.angular.z * delta;
    if (piece.mesh.material && "opacity" in piece.mesh.material) {
      piece.mesh.material.opacity = Math.max(0, piece.life / 2.2);
    }
    if (piece.life <= 0) {
      scene.remove(piece.mesh);
      bossDeathPieces.splice(i, 1);
    }
  }
  if (bossDeathPieces.length === 0) {
    isBossDying = false;
  }
}

function shootFocusedVolley() {
  if (!boss) return;
  const muzzle = new THREE.Vector3(boss.position.x, boss.position.y + 4.2, boss.position.z + 0.6);
  tmpVecA.subVectors(camera.position, muzzle).normalize();
  const spreads = [-6, 0, 6];
  for (let i = 0; i < spreads.length; i++) {
    const dir = tmpVecA.clone().applyAxisAngle(worldUp, THREE.MathUtils.degToRad(spreads[i]));
    dir.y += THREE.MathUtils.randFloat(-0.05, 0.05);
    dir.normalize();
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.95, 18, 18),
      new THREE.MeshBasicMaterial({ color: 0xff44ff, transparent: true, opacity: 0.9 })
    );
    orb.position.copy(muzzle);
    registerBossAttack(orb, dir.multiplyScalar(24), {
      life: 4,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-3, 3),
        THREE.MathUtils.randFloat(-3, 3),
        THREE.MathUtils.randFloat(-3, 3)
      )
    });
  }
  const burst = new THREE.PointLight(0xff66ff, 16, 28);
  burst.position.copy(muzzle);
  scene.add(burst);
  setTimeout(() => scene.remove(burst), 220);
}

function shootCrystalSpread() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 4.8, boss.position.z);
  for (let i = -2; i <= 2; i++) {
    const shard = new THREE.Mesh(
      new THREE.OctahedronGeometry(0.7, 0),
      new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.85 })
    );
    shard.position.copy(origin);
    tmpVecA.subVectors(camera.position, origin).normalize();
    tmpVecA.applyAxisAngle(worldUp, THREE.MathUtils.degToRad(i * 4.5));
    tmpVecA.y += THREE.MathUtils.randFloat(-0.08, 0.08);
    tmpVecA.normalize();
    registerBossAttack(shard, tmpVecA.multiplyScalar(20 + Math.abs(i) * 2), {
      life: 3.6,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4)
      )
    });
  }
}

function shootRadialVolley() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 3.6, boss.position.z);
  const count = 16;
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2;
    const bolt = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 12, 12),
      new THREE.MeshBasicMaterial({ color: 0x44ffee, transparent: true, opacity: 0.75 })
    );
    bolt.position.copy(origin);
    const dir = new THREE.Vector3(
      Math.cos(angle),
      THREE.MathUtils.randFloat(-0.15, 0.15),
      Math.sin(angle)
    );
    registerBossAttack(bolt, dir.normalize().multiplyScalar(18), {
      life: 4.5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2)
      )
    });
  }
  const ringLight = new THREE.PointLight(0x33ffee, 18, 32);
  ringLight.position.copy(origin);
  scene.add(ringLight);
  setTimeout(() => scene.remove(ringLight), 320);
}

function shootHomingShards() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 3.2, boss.position.z);
  for (let i = 0; i < 5; i++) {
    const shard = new THREE.Mesh(
      new THREE.TetrahedronGeometry(0.9, 0),
      new THREE.MeshBasicMaterial({ color: 0xffff66, transparent: true, opacity: 0.85 })
    );
    shard.position.copy(origin);
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.6),
      THREE.MathUtils.randFloat(-0.1, 0.4),
      THREE.MathUtils.randFloatSpread(0.6)
    ).normalize();
    registerBossAttack(shard, dir.multiplyScalar(12), {
      life: 5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5)
      ),
      homing: true
    });
  }
  const glow = new THREE.PointLight(0xffff66, 12, 28);
  glow.position.copy(origin);
  scene.add(glow);
  setTimeout(() => scene.remove(glow), 260);
}

function launchSingleStrike() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 5.2, boss.position.z);
  const projectile = new THREE.Mesh(
    new THREE.SphereGeometry(1, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.85 })
  );
  projectile.position.copy(origin);
  tmpVecA.subVectors(camera.position, origin).normalize();
  tmpVecA.x += THREE.MathUtils.randFloatSpread(0.2);
  tmpVecA.y += THREE.MathUtils.randFloatSpread(0.15);
  tmpVecA.normalize();
  registerBossAttack(projectile, tmpVecA.multiplyScalar(22), {
    life: 4.5,
    spin: new THREE.Vector3(
      THREE.MathUtils.randFloat(-2.5, 2.5),
      THREE.MathUtils.randFloat(-2.5, 2.5),
      THREE.MathUtils.randFloat(-2.5, 2.5)
    )
  });
  const light = new THREE.PointLight(0xff00ff, 12, 26);
  light.position.copy(origin);
  scene.add(light);
  setTimeout(() => scene.remove(light), 240);
}

function launchTripleScatter() {
  if (!boss) return;
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      if (!boss || !gameActive || victoryAchieved || defeat) return;
      const muzzle = new THREE.Vector3(boss.position.x, boss.position.y + 6.2, boss.position.z);
      const bolt = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 2.2, 14),
        new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.95 })
      );
      bolt.position.copy(muzzle);
      const direction = new THREE.Vector3();
      direction.subVectors(camera.position, muzzle).normalize();
      direction.x += THREE.MathUtils.randFloatSpread(0.3);
      direction.y += THREE.MathUtils.randFloatSpread(0.2);
      direction.normalize();
      const velocity = direction.multiplyScalar(24);
      bolt.lookAt(camera.position);
      bolt.rotateX(Math.PI / 2);
      registerBossAttack(bolt, velocity, {
        life: 4.2,
        alignToVelocity: true,
        spin: new THREE.Vector3(
          THREE.MathUtils.randFloat(-1.2, 1.2),
          THREE.MathUtils.randFloat(-0.6, 0.6),
          THREE.MathUtils.randFloat(-1.2, 1.2)
        )
      });
    }, i * 160);
  }
  return { cooldown: THREE.MathUtils.randFloat(1.2, 1.8) };
}

function launchCircularBarrage() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 4.8, boss.position.z);
  const bulletCount = 12;
  for (let i = 0; i < bulletCount; i++) {
    const angle = (i / bulletCount) * Math.PI * 2;
    const shard = new THREE.Mesh(
      new THREE.OctahedronGeometry(0.6, 0),
      new THREE.MeshBasicMaterial({ color: 0x00ff99, transparent: true, opacity: 0.85 })
    );
    shard.position.copy(origin);
    const direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
    registerBossAttack(shard, direction.multiplyScalar(18), {
      life: 5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2)
      )
    });
  }
  const light = new THREE.PointLight(0x00ff99, 16, 32);
  light.position.copy(origin);
  scene.add(light);
  setTimeout(() => scene.remove(light), 300);
  return { cooldown: THREE.MathUtils.randFloat(1.1, 1.6) };
}

function launchPiercingLaser() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 5.4, boss.position.z);
  const laserGeometry = new THREE.CylinderGeometry(0.35, 0.35, 26, 16, 1, true);
  const laserMaterial = new THREE.MeshBasicMaterial({ color: 0x66faff, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
  const laser = new THREE.Mesh(laserGeometry, laserMaterial);
  laser.position.copy(origin);
  const direction = new THREE.Vector3();
  direction.subVectors(camera.position, origin).normalize();
  const quaternion = new THREE.Quaternion();
  quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
  laser.quaternion.copy(quaternion);
  const velocity = direction.clone().multiplyScalar(38);
  const light = new THREE.PointLight(0x66faff, 18, 40);
  light.position.copy(origin);
  scene.add(light);
  registerBossAttack(laser, velocity, {
    life: 3.2,
    alignToVelocity: true,
    speedDamping: 0.06,
    damage: 2,
    onUpdate: (attack) => {
      if (attack.mesh.material && attack.mesh.material.opacity !== undefined) {
        attack.mesh.material.opacity = Math.max(0.25, attack.life / 3.2);
      }
      light.position.copy(attack.mesh.position);
    },
    cleanup: () => {
      scene.remove(light);
    }
  });
  return { cooldown: THREE.MathUtils.randFloat(1.6, 2.3) };
}

function startTauntSequence() {
  if (!boss || bossTaunting) {
    return { cooldown: THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX) };
  }
  bossTaunting = true;
  bossTauntTimer = BOSS_TAUNT_DURATION;
  bossTauntPhase = 0;
  bossTauntPulseTimer = 0;
  const tauntLight = new THREE.PointLight(0xffff66, 26, 44);
  tauntLight.position.copy(boss.position);
  scene.add(tauntLight);
  setTimeout(() => scene.remove(tauntLight), 520);
  spawnTauntParticles(56);
  return { cooldown: BOSS_TAUNT_COOLDOWN };
}

// Battle.html style attack patterns
function launchBattleStyleSingle() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 5, boss.position.z);
  const projectile = new THREE.Mesh(
    new THREE.SphereGeometry(1, 16, 16),
    new THREE.MeshBasicMaterial({ 
      color: 0xff00ff, 
      transparent: true, 
      opacity: 0.8 
    })
  );
  projectile.position.copy(origin);
  tmpVecA.subVectors(camera.position, origin).normalize();
  tmpVecA.x += (Math.random() - 0.5) * 0.2;
  tmpVecA.y += (Math.random() - 0.5) * 0.2;
  tmpVecA.normalize();
  registerBossAttack(projectile, tmpVecA.multiplyScalar(20), {
    life: 4,
    spin: new THREE.Vector3(
      THREE.MathUtils.randFloat(-3, 3),
      THREE.MathUtils.randFloat(-3, 3),
      THREE.MathUtils.randFloat(-3, 3)
    )
  });
  const light = new THREE.PointLight(0xff00ff, 10, 20);
  light.position.copy(origin);
  scene.add(light);
  setTimeout(() => scene.remove(light), 200);
  return { cooldown: THREE.MathUtils.randFloat(1.0, 1.5) };
}

function launchBattleStyleTriple() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 8, boss.position.z);
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      if (!boss || !gameActive || victoryAchieved || defeat) return;
      const projectile = new THREE.Mesh(
        new THREE.ConeGeometry(0.5, 2, 8),
        new THREE.MeshBasicMaterial({ 
          color: 0xff8800, 
          transparent: true, 
          opacity: 0.9 
        })
      );
      projectile.position.copy(origin);
      const direction = new THREE.Vector3();
      direction.subVectors(camera.position, origin).normalize();
      direction.x += (Math.random() - 0.5) * 0.3;
      direction.normalize();
      const velocity = direction.multiplyScalar(25);
      projectile.lookAt(camera.position);
      registerBossAttack(projectile, velocity, {
        life: 4,
        alignToVelocity: true,
        spin: new THREE.Vector3(
          THREE.MathUtils.randFloat(-2, 2),
          THREE.MathUtils.randFloat(-1, 1),
          THREE.MathUtils.randFloat(-2, 2)
        )
      });
    }, i * 200);
  }
  return { cooldown: THREE.MathUtils.randFloat(1.2, 1.8) };
}

function launchBattleStyleCircular() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 5, boss.position.z);
  const bulletCount = 12;
  for (let i = 0; i < bulletCount; i++) {
    const angle = (i / bulletCount) * Math.PI * 2;
    const projectile = new THREE.Mesh(
      new THREE.OctahedronGeometry(0.6, 0),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        transparent: true, 
        opacity: 0.8 
      })
    );
    projectile.position.copy(origin);
    const direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
    registerBossAttack(projectile, direction.multiplyScalar(15), {
      life: 5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2)
      )
    });
  }
  const light = new THREE.PointLight(0x00ff00, 20, 30);
  light.position.copy(origin);
  scene.add(light);
  setTimeout(() => scene.remove(light), 300);
  return { cooldown: THREE.MathUtils.randFloat(1.5, 2.0) };
}

function launchBattleStyleLaser() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 5, boss.position.z);
  const laserGeometry = new THREE.CylinderGeometry(0.3, 0.3, 50, 8);
  const laserMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.9
  });
  const laser = new THREE.Mesh(laserGeometry, laserMaterial);
  laser.position.copy(origin);
  const direction = new THREE.Vector3();
  direction.subVectors(camera.position, origin).normalize();
  const quaternion = new THREE.Quaternion();
  quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
  laser.quaternion.copy(quaternion);
  const velocity = direction.clone().multiplyScalar(40);
  const light = new THREE.PointLight(0x00ffff, 30, 40);
  light.position.copy(origin);
  scene.add(light);
  registerBossAttack(laser, velocity, {
    life: 3.2,
    alignToVelocity: true,
    speedDamping: 0.06,
    damage: 2,
    onUpdate: (attack) => {
      if (attack.mesh.material && attack.mesh.material.opacity !== undefined) {
        attack.mesh.material.opacity = Math.max(0.25, attack.life / 3.2);
      }
      light.position.copy(attack.mesh.position);
    },
    cleanup: () => {
      scene.remove(light);
    }
  });
  return { cooldown: THREE.MathUtils.randFloat(2.0, 2.5) };
}

function launchBattleStyleTaunt() {
  if (!boss || bossTaunting) {
    return { cooldown: THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX) };
  }
  bossTaunting = true;
  bossTauntTimer = 3.0;
  bossTauntPhase = 0;
  bossTauntPulseTimer = 0;
  
  const tauntStartLight = new THREE.PointLight(0xffff00, 30, 50);
  tauntStartLight.position.copy(boss.position);
  scene.add(tauntStartLight);
  setTimeout(() => scene.remove(tauntStartLight), 500);
  
  // Spawn taunt particles
  const particleCount = 50;
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 8, 8),
      new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.8
      })
    );
    particle.position.copy(boss.position);
    const angle = (i / particleCount) * Math.PI * 2;
    const speed = 10 + Math.random() * 10;
    const velocity = new THREE.Vector3(
      Math.cos(angle) * speed,
      Math.random() * 10 - 5,
      Math.sin(angle) * speed
    );
    particle.material.depthWrite = false;
    scene.add(particle);
    bossTauntParticles.push({
      mesh: particle,
      velocity,
      life: 1.2 + Math.random() * 0.6
    });
  }
  
  
  return { cooldown: 4.0 };
}

// Additional advanced attack patterns
function launchAdvancedHoming() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 3.2, boss.position.z);
  for (let i = 0; i < 5; i++) {
    const projectile = new THREE.Mesh(
      new THREE.TetrahedronGeometry(0.9, 0),
      new THREE.MeshBasicMaterial({ 
        color: 0xffff66, 
        transparent: true, 
        opacity: 0.85 
      })
    );
    projectile.position.copy(origin);
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.6),
      THREE.MathUtils.randFloat(-0.1, 0.4),
      THREE.MathUtils.randFloatSpread(0.6)
    ).normalize();
    registerBossAttack(projectile, dir.multiplyScalar(12), {
      life: 5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5)
      ),
      homing: true
    });
  }
  const glow = new THREE.PointLight(0xffff66, 12, 28);
  glow.position.copy(origin);
  scene.add(glow);
  setTimeout(() => scene.remove(glow), 260);
  return { cooldown: THREE.MathUtils.randFloat(1.8, 2.2) };
}

function launchSpeedVariableAttack() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 4, boss.position.z);
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const projectile = new THREE.Mesh(
      new THREE.SphereGeometry(0.8, 12, 12),
      new THREE.MeshBasicMaterial({ 
        color: 0xff6600, 
        transparent: true, 
        opacity: 0.9 
      })
    );
    projectile.position.copy(origin);
    const direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
    const initialSpeed = 25 + Math.random() * 10;
    registerBossAttack(projectile, direction.multiplyScalar(initialSpeed), {
      life: 4,
      speedDamping: 0.8,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4)
      ),
      onUpdate: (attack) => {
        // Speed up after slowing down
        if (attack.life < 2) {
          attack.velocity.multiplyScalar(1.05);
        }
      }
    });
  }
  const light = new THREE.PointLight(0xff6600, 15, 25);
  light.position.copy(origin);
  scene.add(light);
  setTimeout(() => scene.remove(light), 300);
  return { cooldown: THREE.MathUtils.randFloat(1.6, 2.1) };
}

function launchSpiralBarrage() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 6, boss.position.z);
  let spiralAngle = 0;
  for (let i = 0; i < 15; i++) {
    setTimeout(() => {
      if (!boss || !gameActive || victoryAchieved || defeat) return;
      const projectile = new THREE.Mesh(
        new THREE.OctahedronGeometry(0.5, 0),
        new THREE.MeshBasicMaterial({ 
          color: 0x00ccff, 
          transparent: true, 
          opacity: 0.8 
        })
      );
      projectile.position.copy(origin);
      const radius = 0.8 + (i * 0.1);
      const direction = new THREE.Vector3(
        Math.cos(spiralAngle) * radius,
        -0.2,
        Math.sin(spiralAngle) * radius
      ).normalize();
      registerBossAttack(projectile, direction.multiplyScalar(22), {
        life: 4.2,
        spin: new THREE.Vector3(
          THREE.MathUtils.randFloat(-6, 6),
          THREE.MathUtils.randFloat(-6, 6),
          THREE.MathUtils.randFloat(-6, 6)
        )
      });
      spiralAngle += 0.8;
    }, i * 100);
  }
  return { cooldown: THREE.MathUtils.randFloat(2.2, 2.8) };
}

function launchWaveAttack() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 2, boss.position.z);
  for (let wave = 0; wave < 3; wave++) {
    setTimeout(() => {
      if (!boss || !gameActive || victoryAchieved || defeat) return;
      const waveCount = 8;
      for (let i = 0; i < waveCount; i++) {
        const angle = (i / waveCount) * Math.PI * 2;
        const projectile = new THREE.Mesh(
          new THREE.SphereGeometry(0.7, 10, 10),
          new THREE.MeshBasicMaterial({ 
            color: wave === 0 ? 0xff0088 : wave === 1 ? 0x8800ff : 0x0088ff, 
            transparent: true, 
            opacity: 0.85 
          })
        );
        projectile.position.copy(origin);
        const direction = new THREE.Vector3(
          Math.cos(angle + wave * 0.3),
          0,
          Math.sin(angle + wave * 0.3)
        );
        const speed = 18 - wave * 2;
        registerBossAttack(projectile, direction.multiplyScalar(speed), {
          life: 4.5,
          spin: new THREE.Vector3(
            THREE.MathUtils.randFloat(-3, 3),
            THREE.MathUtils.randFloat(-3, 3),
            THREE.MathUtils.randFloat(-3, 3)
          )
        });
      }
      const waveLight = new THREE.PointLight(
        wave === 0 ? 0xff0088 : wave === 1 ? 0x8800ff : 0x0088ff, 
        20, 35
      );
      waveLight.position.copy(origin);
      scene.add(waveLight);
      setTimeout(() => scene.remove(waveLight), 250);
    }, wave * 600);
  }
  return { cooldown: THREE.MathUtils.randFloat(2.5, 3.2) };
}

function spawnTauntParticles(count = 48) {
  if (!boss) return;
  for (let i = 0; i < count; i++) {
    const particle = new THREE.Mesh(
      new THREE.SphereGeometry(0.24, 8, 8),
      new THREE.MeshBasicMaterial({ color: 0xffff66, transparent: true, opacity: 0.9 })
    );
    particle.position.set(boss.position.x, boss.position.y + 1.8, boss.position.z);
    const angle = (i / count) * Math.PI * 2;
    const speed = THREE.MathUtils.randFloat(6, 12);
    const velocity = new THREE.Vector3(
      Math.cos(angle) * speed,
      THREE.MathUtils.randFloat(-3, 5),
      Math.sin(angle) * speed
    );
    particle.material.depthWrite = false;
    scene.add(particle);
    bossTauntParticles.push({
      mesh: particle,
      velocity,
      life: 1.2 + Math.random() * 0.6
    });
  }
}

const bossAttackBehaviors = [
  launchSingleStrike,
  launchTripleScatter,
  launchCircularBarrage,
  launchPiercingLaser,
  startTauntSequence,
  shootFocusedVolley,
  shootCrystalSpread,
  shootRadialVolley,
  shootHomingShards,
  // Battle.html style attacks
  launchBattleStyleSingle,
  launchBattleStyleTriple,
  launchBattleStyleCircular,
  launchBattleStyleLaser,
  launchBattleStyleTaunt,
  // Advanced attack patterns
  launchAdvancedHoming,
  launchSpeedVariableAttack,
  launchSpiralBarrage,
  launchWaveAttack
];

function performBossAttack() {
  if (!gameActive || victoryAchieved || defeat || bossStunned || bossTaunting) return;
  if (bossAttackBehaviors.length === 0) return;
  
  // Mix sequential and random selection for more variety
  let index;
  if (Math.random() < 0.7) {
    // 70% chance for sequential pattern
    index = bossAttackPattern % bossAttackBehaviors.length;
    bossAttackPattern = (index + 1) % bossAttackBehaviors.length;
  } else {
    // 30% chance for random selection
    index = Math.floor(Math.random() * bossAttackBehaviors.length);
  }
  
  const attackFn = bossAttackBehaviors[index];
  if (typeof attackFn !== "function") {
    bossAttackPattern = 0;
    return;
  }
  const result = attackFn();
  const nextCooldown = result && typeof result.cooldown === "number"
    ? result.cooldown
    : THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
  attackCooldownTimer = nextCooldown;
}


function updateBossBehavior(delta) {
  if (!boss || !gameActive) return;
  bossTime += delta;
  bossMoveTimer += delta;
  bossHitReaction = Math.max(0, bossHitReaction - delta * 1.5);

  // 挑発状態の管理
  if (bossTaunting) {
    bossTauntTimer -= delta;
    
    // 挑発フェーズの管理
    if (bossTauntTimer > 2.0) {
      bossTauntPhase = 0; // 笑い始め
    } else if (bossTauntTimer > 1.0) {
      bossTauntPhase = 1; // 激しく笑う
    } else {
      bossTauntPhase = 2; // 笑い終わり
    }
    
    // 笑っているような動き
    const laughIntensity = bossTauntPhase === 1 ? 2.0 : 1.0;
    const laughSpeed = bossTauntPhase === 1 ? 15.0 : 8.0;
    
    // 上下に激しく揺れる
    boss.position.y = BOSS_BASE_HEIGHT + Math.sin(bossTime * laughSpeed) * laughIntensity * 2;
    
    // 前後に揺れる（お辞儀するような動き）
    boss.rotation.x = Math.sin(bossTime * laughSpeed * 0.7) * 0.3 * laughIntensity;
    
    // 左右に揺れる
    boss.rotation.z = Math.sin(bossTime * laughSpeed * 0.5) * 0.2 * laughIntensity;
    
    // サイズを脈動させる
    const scaleEffect = 1 + Math.sin(bossTime * laughSpeed * 0.8) * 0.1 * laughIntensity;
    boss.scale.set(scaleEffect, scaleEffect, scaleEffect);
    
    // ボスを黄色く光らせる
    boss.traverse((child) => {
      if (child.isMesh && child.material && child !== bossWeakPoint) {
        if (!child.material.userData) child.material.userData = {};
        
        // 初回のみ元の色を保存
        if (!child.material.userData.originalEmissive) {
          child.material.userData.originalEmissive = child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000);
          child.material.userData.originalEmissiveIntensity = child.material.emissiveIntensity || 0.5;
          child.material.userData.originalColor = child.material.color ? child.material.color.clone() : new THREE.Color(0xffffff);
        }
        
        if (child.material.emissive) {
          // 元の色と黄色をブレンド
          const originalEmissive = child.material.userData.originalEmissive;
          const glowColor = new THREE.Color(0xffff00);
          child.material.emissive.copy(originalEmissive).lerp(glowColor, 0.6 * laughIntensity);
          child.material.emissiveIntensity = child.material.userData.originalEmissiveIntensity + Math.sin(bossTime * 10) * 0.5;
        }
      }
    });
    
    // 挑発中に小さな光のパーティクルを放出
    if (Math.random() < 0.1) {
      const spark = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({
          color: 0xffff00,
          transparent: true,
          opacity: 1
        })
      );
      spark.position.copy(boss.position);
      spark.position.x += (Math.random() - 0.5) * 10;
      spark.position.y += (Math.random() - 0.5) * 10;
      spark.position.z += (Math.random() - 0.5) * 10;
      scene.add(spark);
      setTimeout(() => scene.remove(spark), 500);
    }
    
    // 挑発終了
    if (bossTauntTimer <= 0) {
      bossTaunting = false;
      bossTauntTimer = 0;
      bossTauntPhase = 0;
      bossTauntPulseTimer = 0;
      boss.scale.set(1, 1, 1);
      
      // 色を元に戻す - より確実な方法
      restoreBossOriginalColors();
      
      // 挑発後の強力な攻撃
      setTimeout(() => {
        if (gameActive && !bossTaunting && !victoryAchieved && !defeat) {
          // 全方向弾幕攻撃
          const bulletCount = 20;
          const burstOrigin = new THREE.Vector3(boss.position.x, boss.position.y + 5, boss.position.z);
          for (let i = 0; i < bulletCount; i++) {
            const angle = (i / bulletCount) * Math.PI * 2;
            const burstProjectile = new THREE.Mesh(
              new THREE.SphereGeometry(1.2, 16, 16),
              new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.9
              })
            );
            burstProjectile.position.copy(burstOrigin);
            const direction = new THREE.Vector3(
              Math.cos(angle),
              (Math.random() - 0.5) * 0.5,
              Math.sin(angle)
            );
            registerBossAttack(burstProjectile, direction.multiplyScalar(20), {
              life: 4.5,
              spin: new THREE.Vector3(
                THREE.MathUtils.randFloat(-3, 3),
                THREE.MathUtils.randFloat(-3, 3),
                THREE.MathUtils.randFloat(-3, 3)
              )
            });
          }
          const burstLight = new THREE.PointLight(0xff00ff, 40, 50);
          burstLight.position.copy(burstOrigin);
          scene.add(burstLight);
          setTimeout(() => scene.remove(burstLight), 500);
        }
      }, 300);
    }
  }

  // 停止状態の管理
  if (bossStunned) {
    bossStunTimer -= delta;
    bossFlashTimer -= delta;
    
    // 点滅エフェクトの管理
    if (bossFlashTimer > 0) {
      const flashIntensity = Math.sin(bossFlashTimer * 20) * 0.5 + 0.5;
      const flashColor = new THREE.Color(0xff0000);
      const flashEmissive = new THREE.Color(0xff0000);
      
      boss.traverse((child) => {
        if (child.isMesh && child !== bossWeakPoint) {
          const material = child.material;
          if (!material.userData) material.userData = {};
          if (!material.userData.originalColor) {
            material.userData.originalColor = material.color.clone();
          }
          if (material.emissive && !material.userData.originalEmissive) {
            material.userData.originalEmissive = material.emissive.clone();
          }
          
          // 連続的な点滅
          material.color.lerp(flashColor, flashIntensity * 0.6);
          if (material.emissive) {
            material.emissive.lerp(flashEmissive, flashIntensity * 0.8);
          }
        }
      });
    } else {
      // 点滅が終わったら元の色に戻す
      restoreBossOriginalColors();
    }
    
    if (bossStunTimer <= 0) {
      bossStunned = false;
      // 停止が終わったら新しい位置を設定
      setBossTargetAroundPlayer();
    }
    // 停止中は移動しないが、アニメーションは続ける
    // アニメーション部分は下に移動
  } else if (!bossTaunting) {
    // 通常時のみ移動処理（挑発中は移動しない）
    updateBossTargetPositionFromPlayer();

    if (bossMoveTimer >= BOSS_MOVE_INTERVAL) {
      bossMoveTimer = 0;
      setBossTargetAroundPlayer();
    }

    boss.position.x += (bossTargetPosition.x - boss.position.x) * delta * 2.4;
    boss.position.z += (bossTargetPosition.z - boss.position.z) * delta * 2.4;
    
    // 高さのアニメーション（通常時のみ）
    const idleHeight = BOSS_BASE_HEIGHT + Math.sin(bossTime * 2.2) * 0.6;
    boss.position.y = idleHeight + bossHitReaction * 0.6;
  }

  // 挑発中は通常の回転処理をスキップ
  if (!bossTaunting) {
    tmpVecA.subVectors(camera.position, boss.position);
    const horizontalDistance = Math.hypot(tmpVecA.x, tmpVecA.z) || 0.0001;
    const desiredYaw = Math.atan2(tmpVecA.x, tmpVecA.z);
    const desiredPitch = Math.atan2(tmpVecA.y, horizontalDistance);
    const orientationLerp = 1 - Math.exp(-delta * 8);

    let yawDiff = desiredYaw - boss.rotation.y;
    yawDiff = THREE.MathUtils.euclideanModulo(yawDiff + Math.PI, Math.PI * 2) - Math.PI;
    boss.rotation.y += yawDiff * orientationLerp;
    boss.rotation.x = THREE.MathUtils.lerp(boss.rotation.x, -desiredPitch * 0.6 + bossHitReaction * 0.12, orientationLerp);

    const leanTarget = THREE.MathUtils.clamp((bossTargetPosition.x - boss.position.x) * -0.03, -0.35, 0.35);
    boss.rotation.z = THREE.MathUtils.lerp(boss.rotation.z, leanTarget, orientationLerp);
  }

  if (bossHitReaction > 0) {
    boss.position.x += Math.sin(bossTime * 42) * bossHitReaction * 1.6;
    boss.position.y += Math.cos(bossTime * 38) * bossHitReaction * 0.9;
  }

  if (bossCore) {
    if (bossTaunting) {
      // 挑発中はより激しく回転
      bossCore.rotation.x += delta * 8;
      bossCore.rotation.y += delta * 10;
      const scale = 1 + Math.sin(bossTime * 12) * 0.3;
      bossCore.scale.setScalar(scale);
    } else {
      bossCore.rotation.x += delta * 2.6;
      bossCore.rotation.y += delta * 3.1;
      const scale = 1 + Math.sin(bossTime * 4.2) * 0.1 + bossHitReaction * 0.05;
      bossCore.scale.setScalar(scale);
    }
  }

  bossFloatingCrystals.forEach((crystal, index) => {
    if (bossTaunting) {
      // 挑発中はより激しく動く
      const angle = bossTime * 6 + (index / bossFloatingCrystals.length) * Math.PI * 2;
      crystal.position.x = Math.cos(angle) * 6;
      crystal.position.z = Math.sin(angle) * 6;
      crystal.position.y = Math.sin(bossTime * 8 + index) * 4;
      crystal.rotation.x += delta * 15;
      crystal.rotation.y += delta * 12;
    } else {
      const angle = bossTime * 2 + (index / bossFloatingCrystals.length) * Math.PI * 2;
      crystal.position.x = Math.cos(angle) * 4;
      crystal.position.z = Math.sin(angle) * 4;
      crystal.position.y = Math.sin(bossTime * 3 + index) * 2.2;
      crystal.rotation.x += delta * 5;
      crystal.rotation.y += delta * 3;
    }
  });

  bossEnergyRings.forEach((ring, index) => {
    if (bossTaunting) {
      // 挑発中はより激しく回転
      ring.rotation.z += delta * (3 + index * 1.5);
      const scale = 1 + Math.sin(bossTime * 8 + index) * 0.3;
      ring.scale.setScalar(scale);
    } else {
      ring.rotation.z += delta * (1 + index * 0.5);
      const scale = 1 + Math.sin(bossTime * 2.2 + index) * 0.1;
      ring.scale.setScalar(scale);
    }
  });

  bossShoulders.forEach((data) => {
    const offset = data.phase || 0;
    if (bossTaunting) {
      // 挑発中はより激しく動く
      data.group.position.y = 5 + Math.sin(bossTime * 8 + offset) * 4;
      data.group.rotation.z = Math.sin(bossTime * 6 + offset) * 0.8;
      if (data.cannon && data.cannon.material && data.cannon.material.emissive) {
        data.cannon.material.emissiveIntensity = 2 + Math.sin(bossTime * 15 + offset) * 1.5;
      }
    } else {
      data.group.position.y = 5 + Math.sin(bossTime * 2 + offset) * 2;
      data.group.rotation.z = Math.sin(bossTime * 1.5 + offset) * 0.3;
      if (data.cannon && data.cannon.material && data.cannon.material.emissive) {
        data.cannon.material.emissiveIntensity = 1 + Math.sin(bossTime * 6 + offset) * 0.5;
      }
    }
  });

  bossWings.forEach((data) => {
    const offset = data.phase || 0;
    if (bossTaunting) {
      // 挑発中はより激しく動く
      data.group.rotation.y = Math.sin(bossTime * 8 + offset) * 1.2;
      data.group.position.z = -4 + Math.sin(bossTime * 10 + offset) * 5;
    } else {
      data.group.rotation.y = Math.sin(bossTime * 2 + offset) * 0.5;
      data.group.position.z = -4 + Math.sin(bossTime * 3 + offset) * 2;
    }
  });

  if (bossWeakPoint) {
    bossWeakPointGlow += delta;
    const pulse = 1 + Math.sin(bossWeakPointGlow * 6) * 0.35;
    bossWeakPoint.scale.setScalar(pulse);
    if (bossWeakPoint.material && bossWeakPoint.material.emissive) {
      bossWeakPoint.material.emissiveIntensity = 2 + Math.sin(bossWeakPointGlow * 8) * 0.6;
    }
    bossWeakPoint.rotation.x += delta * 3;
    bossWeakPoint.rotation.z += delta * 2;
  }
}

function applyCameraRotation() {
  cameraEuler.set(pitch, yaw, 0);
  camera.quaternion.setFromEuler(cameraEuler);
}

function updateMovement(delta) {
  const joystickX = Math.abs(moveJoystickData.x) > 0.01 ? moveJoystickData.x : 0;
  const joystickY = Math.abs(moveJoystickData.y) > 0.01 ? moveJoystickData.y : 0;
  inputVector.set(joystickX, 0, -joystickY);
  if (inputVector.x === 0 && inputVector.z === 0) return;
  if (inputVector.lengthSq() > 1) {
    inputVector.normalize();
  }
  forwardVector.set(0, 0, -1).applyQuaternion(camera.quaternion);
  forwardVector.y = 0;
  if (forwardVector.lengthSq() > 0.0001) {
    forwardVector.normalize();
  } else {
    forwardVector.set(0, 0, -1);
  }
  rightVector.crossVectors(forwardVector, worldUp);
  if (rightVector.lengthSq() > 0.0001) {
    rightVector.normalize();
  } else {
    rightVector.set(1, 0, 0);
  }
  displacement.copy(forwardVector).multiplyScalar(inputVector.z);
  displacement.addScaledVector(rightVector, inputVector.x);
  if (displacement.lengthSq() === 0) return;
  displacement.normalize().multiplyScalar((isMobile ? MOBILE_MOVE_SPEED : MOVE_SPEED) * delta);
  camera.position.add(displacement);
  camera.position.y = 1.6;
}

function handleResize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
  renderer.setPixelRatio(dpr);
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

handleResize();
window.addEventListener("resize", handleResize);

const spark = new SparkRenderer({
  renderer,
  maxStdDev: Math.sqrt(5),
  maxPixelRadius: 256,
  clipXY: 2.0,
  view: { stochastic: false, sortRadial: true, sortDistance: 0.01, sortCoorient: 0.995, sort32: false }
});
scene.add(spark);

const loadingEl = document.getElementById("loading");
const splat = new SplatMesh({
  url: SPZ_URL,
  onLoad: () => {
    if (loadingEl) loadingEl.remove();
    renderer.render(scene, camera);
  }
});
splat.scale.setScalar(5);
splat.position.set(0, -1.2, -8);
splat.rotation.set(Math.PI, 0, 0);
scene.add(splat);

function createGyroControls() {
  const deviceOrientation = { alpha: null, beta: null, gamma: null };
  let screenOrientation = window.orientation || 0;
  const zee = new THREE.Vector3(0, 0, 1);
  const euler = new THREE.Euler();
  const q0 = new THREE.Quaternion();
  const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

  const onDeviceOrientationChangeEvent = (event) => {
    deviceOrientation.alpha = event.alpha;
    deviceOrientation.beta = event.beta;
    deviceOrientation.gamma = event.gamma;
  };

  const onScreenOrientationChangeEvent = () => {
    screenOrientation = window.orientation || 0;
  };

  return {
    connect() {
      onScreenOrientationChangeEvent();
      window.addEventListener("orientationchange", onScreenOrientationChangeEvent);
      window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent);
    },
    disconnect() {
      window.removeEventListener("orientationchange", onScreenOrientationChangeEvent);
      window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent);
    },
    update() {
      if (deviceOrientation.alpha === null && deviceOrientation.beta === null && deviceOrientation.gamma === null) {
        return;
      }
      const alpha = deviceOrientation.alpha !== null ? THREE.MathUtils.degToRad(deviceOrientation.alpha) : 0;
      const beta = deviceOrientation.beta !== null ? THREE.MathUtils.degToRad(deviceOrientation.beta) : 0;
      const gamma = deviceOrientation.gamma !== null ? THREE.MathUtils.degToRad(deviceOrientation.gamma) : 0;
      const orient = THREE.MathUtils.degToRad(screenOrientation);
      euler.set(beta, alpha, -gamma, "YXZ");
      camera.quaternion.setFromEuler(euler);
      camera.quaternion.multiply(q1);
      camera.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
      cameraEuler.setFromQuaternion(camera.quaternion);
      pitch = cameraEuler.x;
      yaw = cameraEuler.y;
    }
  };
}

async function setupGyroscope() {
  if (!isMobile || gyroActive || typeof DeviceOrientationEvent === "undefined") {
    return false;
  }
  if (typeof DeviceOrientationEvent.requestPermission === "function") {
    try {
      const permission = await DeviceOrientationEvent.requestPermission();
      if (permission !== "granted") {
        return false;
      }
    } catch (error) {
      console.error("Failed to enable gyroscope:", error);
      return false;
    }
  }
  if (!gyroControls) {
    gyroControls = createGyroControls();
    gyroControls.connect();
  }
  gyroActive = true;
  isGyroAvailable = true;
  touchLookActive = false;
  if (document.pointerLockElement) {
    document.exitPointerLock();
  }
  pointerLocked = false;
  renderer.domElement.style.cursor = "auto";
  if (gyroPermissionEl) {
    gyroPermissionEl.style.display = "none";
  }
  return true;
}

function setupJoystick(container, stick, callback) {
  let active = false;
  let currentX = 0;
  let currentY = 0;
  const maxDistance = 45;

  function updateStickPosition() {
    stick.style.transform = "translate(calc(-50% + " + currentX + "px), calc(-50% + " + currentY + "px))";
  }

  function handleStart(e) {
    active = true;
    if (e.cancelable !== false) e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = container.getBoundingClientRect();
    currentX = touch.clientX - rect.left - rect.width / 2;
    currentY = touch.clientY - rect.top - rect.height / 2;
    const distance = Math.sqrt(currentX * currentX + currentY * currentY);
    if (distance > maxDistance) {
      currentX = currentX / distance * maxDistance;
      currentY = currentY / distance * maxDistance;
    }
    updateStickPosition();
    callback({ x: currentX / maxDistance, y: currentY / maxDistance });
  }

  function handleMove(e) {
    if (!active) return;
    if (e.cancelable !== false) e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = container.getBoundingClientRect();
    currentX = touch.clientX - rect.left - rect.width / 2;
    currentY = touch.clientY - rect.top - rect.height / 2;
    const distance = Math.sqrt(currentX * currentX + currentY * currentY);
    if (distance > maxDistance) {
      currentX = currentX / distance * maxDistance;
      currentY = currentY / distance * maxDistance;
    }
    updateStickPosition();
    callback({ x: currentX / maxDistance, y: currentY / maxDistance });
  }

  function handleEnd() {
    active = false;
    currentX = 0;
    currentY = 0;
    updateStickPosition();
    callback({ x: 0, y: 0 });
  }

  container.addEventListener("touchstart", handleStart, { passive: false });
  document.addEventListener("touchmove", handleMove, { passive: false });
  document.addEventListener("touchend", handleEnd);
  document.addEventListener("touchcancel", handleEnd);
  container.addEventListener("mousedown", handleStart);
  document.addEventListener("mousemove", handleMove);
  document.addEventListener("mouseup", handleEnd);
  updateStickPosition();
}

function onTouchStartLook(event) {
  if (!isMobile || gyroActive) return;
  if (event.target && typeof event.target.closest === "function") {
    if (event.target.closest("#moveJoystick") || event.target.closest("#shootButton")) {
      return;
    }
  }
  const touch = event.touches && event.touches[0];
  if (!touch) return;
  touchLookActive = true;
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
  if (event.cancelable !== false) event.preventDefault();
}

function onTouchMoveLook(event) {
  if (!touchLookActive || gyroActive) return;
  const touch = event.touches && event.touches[0];
  if (!touch) return;
  const deltaX = touch.clientX - lastTouchX;
  const deltaY = touch.clientY - lastTouchY;
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
  yaw -= deltaX * POINTER_SENSITIVITY;
  pitch -= deltaY * POINTER_SENSITIVITY;
  pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
  applyCameraRotation();
  if (event.cancelable !== false) event.preventDefault();
}

function onTouchEndLook() {
  touchLookActive = false;
}

if (requestGyroButton) {
  requestGyroButton.addEventListener("click", async () => {
    const enabled = await setupGyroscope();
    if (!enabled && gyroPermissionEl) {
      gyroPermissionEl.style.display = "flex";
    }
  });
}

if (isMobile && gyroPermissionEl && typeof DeviceOrientationEvent !== "undefined") {
  if (typeof DeviceOrientationEvent.requestPermission === "function") {
    gyroPermissionEl.style.display = "flex";
  } else {
    setupGyroscope();
  }
}

if (isMobile) {
  if (mobileUI) mobileUI.style.display = "block";
  renderer.domElement.style.touchAction = "none";
  if (moveJoystick && moveStick) {
    setupJoystick(moveJoystick, moveStick, (data) => {
      moveJoystickData = data;
    });
  }
}

renderer.domElement.addEventListener("touchstart", onTouchStartLook, { passive: false });
renderer.domElement.addEventListener("touchmove", onTouchMoveLook, { passive: false });
renderer.domElement.addEventListener("touchend", onTouchEndLook);
renderer.domElement.addEventListener("touchcancel", onTouchEndLook);

document.addEventListener("mousemove", (event) => {
  if (!pointerLocked || gyroActive) return;
  yaw -= event.movementX * POINTER_SENSITIVITY;
  pitch -= event.movementY * POINTER_SENSITIVITY;
  pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
  applyCameraRotation();
});

if (shootButton) {
  shootButton.addEventListener("click", (event) => {
    event.preventDefault();
    shoot();
  });
  shootButton.addEventListener("touchstart", (event) => {
    if (event.cancelable !== false) event.preventDefault();
    shoot();
  }, { passive: false });
}
if (startButton) {
  const triggerStartBattle = () => {
    if (gameActive) return;
  if (!isMobile && !gyroActive) {
    renderer.domElement.requestPointerLock().catch((err) => {
      console.warn('Pointer lock request failed:', err);
    });
  }
    startBattle();
  };
  startButton.addEventListener("click", (event) => {
    event.preventDefault();
    triggerStartBattle();
  });
  startButton.addEventListener("touchstart", (event) => {
    if (event.cancelable !== false) event.preventDefault();
    triggerStartBattle();
  }, { passive: false });
}


document.addEventListener("mousedown", (event) => {
  if (event.button === 0 && !isMobile && !gyroActive && pointerLocked) {
    shoot();
  }
});

renderer.domElement.addEventListener("click", () => {
  if (gyroActive || isMobile) return;
  if (!pointerLocked) {
    renderer.domElement.requestPointerLock().catch((err) => {
      // SecurityError等を静かに処理
      console.warn('Pointer lock request failed:', err);
    });
  }
});

document.addEventListener("pointerlockchange", () => {
  pointerLocked = document.pointerLockElement === renderer.domElement;
  renderer.domElement.style.cursor = pointerLocked ? "none" : (gyroActive ? "auto" : "grab");
});

setBossTargetAroundPlayer();
initializeBoss();
updateHud();
showStartButton();

renderer.setAnimationLoop(() => {
  const delta = clock.getDelta();
  if (gyroActive && gyroControls && isGyroAvailable) {
    gyroControls.update();
  }
  if (shootCooldownTimer > 0) {
    shootCooldownTimer = Math.max(0, shootCooldownTimer - delta);
  }
  if (gameActive && !victoryAchieved && !defeat) {
    attackCooldownTimer -= delta;
    if (attackCooldownTimer <= 0) {
      performBossAttack();
    }
  }
  updateBossBehavior(delta);
  updateMovement(delta);
  updateBullets(delta);
  updateBossAttacks(delta);
  updateBossHitEffects(delta);
  updateBossDeath(delta);
  
  // Update taunt particles
  for (let i = bossTauntParticles.length - 1; i >= 0; i--) {
    const particle = bossTauntParticles[i];
    particle.life -= delta;
    if (particle.mesh) {
      particle.mesh.position.addScaledVector(particle.velocity, delta);
      particle.velocity.multiplyScalar(0.98);
      particle.velocity.y -= delta * 5;
      if (particle.mesh.material) {
        particle.mesh.material.opacity = Math.max(0, particle.life / 1.8);
      }
      if (particle.life <= 0) {
        scene.remove(particle.mesh);
        bossTauntParticles.splice(i, 1);
      }
    }
  }
  
  renderer.render(scene, camera);
});

</script>

</body>
</html>





