<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark Background Demo</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.12em; text-transform: uppercase; z-index: 10; }
    #gyroPermission { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.78); color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; padding: 32px; z-index: 9; }
    #gyroPermission > div { max-width: 320px; }
    #gyroPermission button { margin-top: 20px; padding: 10px 28px; border: 1px solid rgba(255, 255, 255, 0.7); background: transparent; color: #fff; font-size: 0.82rem; letter-spacing: 0.12em; cursor: pointer; }
    #gyroPermission button:active { background: rgba(255, 255, 255, 0.1); }
    #scoreDisplay { position: fixed; top: 24px; left: 24px; color: #fff; font-family: system-ui, sans-serif; letter-spacing: 0.08em; font-size: 0.9rem; text-transform: uppercase; z-index: 8; pointer-events: none; transition: color 0.15s ease, text-shadow 0.15s ease; }
    #scoreDisplay.damage { color: #ff6f91; text-shadow: 0 0 12px rgba(255, 127, 159, 0.8); }
    #crosshair { position: fixed; top: 50%; left: 50%; width: 28px; height: 28px; transform: translate(-50%, -50%); pointer-events: none; z-index: 8; opacity: 0.7; }
    #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.7); }
    #crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; transform: translateY(-50%); }
    #crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #crosshair .circle { position: absolute; width: 16px; height: 16px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.4); top: 50%; left: 50%; transform: translate(-50%, -50%); }
    #crosshair.powered::before, #crosshair.powered::after { background: rgba(173, 235, 255, 0.9); box-shadow: 0 0 6px rgba(120, 210, 255, 0.8); }
    #crosshair.powered .circle { border-color: rgba(173, 235, 255, 0.9); box-shadow: 0 0 8px rgba(120, 210, 255, 0.75); }
    #crosshair.flash { animation: crosshairFlash 0.2s ease-out; }
    @keyframes crosshairFlash { 0% { transform: translate(-50%, -50%) scale(1.3); } 100% { transform: translate(-50%, -50%) scale(1); } }
    #startButton {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 18px 48px;
      border: 1px solid rgba(166, 213, 255, 0.7);
      background: rgba(20, 32, 70, 0.86);
      color: #e8f4ff;
      font-family: system-ui, sans-serif;
      letter-spacing: 0.22em;
      font-size: 0.9rem;
      text-transform: uppercase;
      z-index: 12;
      cursor: pointer;
      box-shadow: 0 0 24px rgba(110, 202, 255, 0.45), inset 0 0 12px rgba(36, 82, 160, 0.6);
      backdrop-filter: blur(4px);
      transition: transform 0.15s ease;
    }
    #startButton:active {
      transform: translate(-50%, -50%) scale(0.97);
    }
    #startButton.hidden {
      display: none;
    }
    #shootButton { position: fixed; bottom: 24px; left: 24px; width: 112px; height: 112px; border-radius: 50%; border: 1px solid rgba(132, 182, 255, 0.6); display: flex; align-items: center; justify-content: center; font-family: system-ui, sans-serif; font-size: 0.78rem; letter-spacing: 0.18em; color: #dff4ff; background: radial-gradient(circle at 30% 30%, rgba(86, 149, 255, 0.55), rgba(18, 37, 82, 0.85) 58%, rgba(7, 12, 28, 0.95)); box-shadow: 0 0 22px rgba(64, 128, 255, 0.42), inset 0 0 18px rgba(22, 90, 150, 0.45); z-index: 7; cursor: pointer; user-select: none; touch-action: none; backdrop-filter: blur(2px); }
    #shootButton::before { content: ''; position: absolute; inset: 8px; border-radius: 50%; border: 1px solid rgba(166, 213, 255, 0.35); box-shadow: inset 0 0 20px rgba(117, 182, 255, 0.35), 0 0 14px rgba(48, 120, 220, 0.35); background: radial-gradient(circle, rgba(72, 140, 255, 0.18), rgba(9, 24, 49, 0.0) 62%); }
    #shootButton::after { content: ''; position: absolute; inset: 0; border-radius: 50%; box-shadow: 0 0 28px rgba(60, 140, 255, 0.4); opacity: 0.7; }
    #shootButton span { position: relative; z-index: 1; margin-top: 28px; opacity: 0.92; text-shadow: 0 0 8px rgba(112, 208, 255, 0.8); }
    #shootButton:active { transform: scale(0.97); box-shadow: 0 0 14px rgba(90, 160, 255, 0.48), inset 0 0 22px rgba(18, 98, 190, 0.6); }
    .shoot-crosshair { position: absolute; width: 58px; height: 58px; top: 42%; left: 50%; transform: translate(-50%, -50%); opacity: 0.9; filter: drop-shadow(0 0 12px rgba(124, 210, 255, 0.65)); }
    .shoot-crosshair::before, .shoot-crosshair::after { content: ''; position: absolute; background: linear-gradient(90deg, rgba(120, 210, 255, 0), rgba(120, 210, 255, 0.95), rgba(120, 210, 255, 0)); }
    .shoot-crosshair::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
    .shoot-crosshair::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
    #mobileUI { position: fixed; bottom: 24px; right: 24px; display: none; z-index: 6; pointer-events: none; }
    #moveJoystick { width: 128px; height: 128px; border-radius: 50%; border: 1px solid rgba(120, 182, 255, 0.45); background: radial-gradient(circle, rgba(60, 102, 166, 0.45), rgba(16, 31, 60, 0.82) 65%, rgba(5, 12, 26, 0.95)); position: relative; pointer-events: auto; touch-action: none; box-shadow: 0 0 24px rgba(54, 122, 220, 0.4), inset 0 0 16px rgba(32, 72, 140, 0.35); backdrop-filter: blur(2px); }
    #moveJoystick::before { content: ''; position: absolute; inset: 18px; border-radius: 50%; border: 1px solid rgba(156, 210, 255, 0.25); box-shadow: inset 0 0 16px rgba(98, 171, 255, 0.35); background: radial-gradient(circle, rgba(94, 162, 255, 0.18), rgba(9, 20, 46, 0)); }
    #moveStick { position: absolute; width: 64px; height: 64px; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(134, 222, 255, 0.7), rgba(53, 128, 210, 0.6) 55%, rgba(7, 16, 36, 0.85)); border: 1px solid rgba(186, 236, 255, 0.85); top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s ease; box-shadow: 0 0 16px rgba(110, 212, 255, 0.6), inset 0 0 12px rgba(42, 108, 188, 0.55); }
    #moveStick::before, #moveStick::after { content: ''; position: absolute; background: linear-gradient(90deg, rgba(162, 232, 255, 0), rgba(162, 232, 255, 0.9), rgba(162, 232, 255, 0)); }
    #moveStick::before { width: 100%; height: 2px; top: 50%; left: 0; transform: translateY(-50%); }
    #moveStick::after { width: 2px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="gyroPermission">
    <div>
      <p>Enable gyroscope aim for mobile.</p>
      <button id="requestGyro">Enable Gyro</button>
    </div>
  </div>
  <div id="scoreDisplay">Press START to begin</div>
  <button id="startButton">START</button>
  <div id="crosshair"><div class="circle"></div></div>
  <div id="shootButton">
    <div class="shoot-crosshair"></div>
    <span>SHOOT</span>
  </div>
  <div id="mobileUI">
    <div id="moveJoystick">
      <div id="moveStick"></div>
    </div>
  </div>
  <script type="module">
import * as THREE from "three";
import { SparkRenderer, SplatMesh } from "@sparkjsdev/spark";

const SPZ_URL = "https://space-gimu.s3.ap-northeast-1.amazonaws.com/space.spz";
const MOVE_SPEED = 3.8;
const MOBILE_MOVE_SPEED = 6.0;
const POINTER_SENSITIVITY = 0.002;
const PITCH_LIMIT = Math.PI / 2 - 0.01;
const BULLET_SPEED = 40;
const BULLET_LIFETIME = 1.6;
const SHOOT_COOLDOWN = 0.18;
const PLAYER_MAX_HEALTH = 5;
const PLAYER_HIT_RADIUS = 1.3;
const BOSS_MAX_HEALTH = 12;
const BOSS_WEAK_POINT_RADIUS = 1.8;
const BOSS_ATTACK_COOLDOWN_MIN = 1.2;
const BOSS_ATTACK_COOLDOWN_MAX = 2.4;
const BOSS_MOVE_INTERVAL = 2.8;
const BOSS_ORBIT_RADIUS_MIN = 26;
const BOSS_ORBIT_RADIUS_MAX = 42;
const BOSS_MODEL_SCALE = 0.9;
const BOSS_BASE_HEIGHT = 6.5;
const BOSS_HIT_EFFECT_DURATION = 0.6;
const BOSS_HIT_SPARK_COUNT = 120;
const BOSS_HIT_ARC_COUNT = 15;
const BOSS_HIT_RING_MAX_SCALE = 7.0;
const BOSS_HIT_PARTICLE_COUNT = 160;

const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.domElement.style.cursor = "grab";
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x040212, 18, 160);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";
camera.position.set(0, 1.6, 3.5);
camera.lookAt(new THREE.Vector3(0, 1.6, -24));

scene.add(new THREE.AmbientLight(0x88aaff, 0.45));
const rimLight = new THREE.DirectionalLight(0xcbd5ff, 0.7);
rimLight.position.set(-6, 8, 12);
scene.add(rimLight);
const fillLight = new THREE.PointLight(0x2233ff, 1.6, 120);
fillLight.position.set(0, 12, -24);
scene.add(fillLight);

const cameraEuler = new THREE.Euler(0, 0, 0, "YXZ");
cameraEuler.setFromQuaternion(camera.quaternion);
let pitch = cameraEuler.x;
let yaw = cameraEuler.y;

const isMobile = /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
const gyroPermissionEl = document.getElementById("gyroPermission");
const requestGyroButton = document.getElementById("requestGyro");
const mobileUI = document.getElementById("mobileUI");
const moveJoystick = document.getElementById("moveJoystick");
const moveStick = document.getElementById("moveStick");
const startButton = document.getElementById("startButton");
const shootButton = document.getElementById("shootButton");
const scoreDisplay = document.getElementById("scoreDisplay");
const crosshair = document.getElementById("crosshair");

let gyroControls = null;
let gyroActive = false;
let isGyroAvailable = false;
let pointerLocked = false;
let moveJoystickData = { x: 0, y: 0 };
let touchLookActive = false;
let lastTouchX = 0;
let lastTouchY = 0;

const bullets = [];
const bossAttacks = [];
const bossDeathPieces = [];
const bossHitEffects = [];
let playerHealth = PLAYER_MAX_HEALTH;
let bossHealth = BOSS_MAX_HEALTH;
let shootCooldownTimer = 0;
let attackCooldownTimer = THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
let bossMoveTimer = 0;
let bossTime = 0;
let bossHitReaction = 0;
let bossAttackPattern = 0;
let bossStunned = false;
let bossStunTimer = 0;
let bossStunDuration = 0.8;
let bossFlashTimer = 0;
let bossFlashDuration = 0.6;
let gameStarted = false;
let gameActive = false;
let victoryAchieved = false;
let defeat = false;
let isBossDying = false;

let boss = null;
let bossCore = null;
let bossWeakPoint = null;
let bossFloatingCrystals = [];
let bossEnergyRings = [];
let bossShoulders = [];
let bossWings = [];
let bossWeakPointGlow = 0;
const bossTargetOffset = new THREE.Vector3(0, 0, -32);
const bossTargetPosition = new THREE.Vector3(
  camera.position.x + bossTargetOffset.x,
  BOSS_BASE_HEIGHT,
  camera.position.z + bossTargetOffset.z
);

const clock = new THREE.Clock();
const worldUp = new THREE.Vector3(0, 1, 0);
const inputVector = new THREE.Vector3();
const forwardVector = new THREE.Vector3();
const rightVector = new THREE.Vector3();
const displacement = new THREE.Vector3();
const bulletStartPosition = new THREE.Vector3();
const bulletDirection = new THREE.Vector3();
const tmpVecA = new THREE.Vector3();
const tmpVecB = new THREE.Vector3();

function updateBossTargetPositionFromPlayer() {
  bossTargetPosition.set(
    camera.position.x + bossTargetOffset.x,
    BOSS_BASE_HEIGHT,
    camera.position.z + bossTargetOffset.z
  );
}

function setBossTargetAroundPlayer() {
  const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
  const radius = THREE.MathUtils.randFloat(BOSS_ORBIT_RADIUS_MIN, BOSS_ORBIT_RADIUS_MAX);
  bossTargetOffset.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
  updateBossTargetPositionFromPlayer();
}
function hideStartButton() {
  if (!startButton) return;
  startButton.classList.add("hidden");
}

function showStartButton(label) {
  if (!startButton) return;
  startButton.textContent = label || "START";
  startButton.classList.remove("hidden");
  if (document.pointerLockElement === renderer.domElement) {
    document.exitPointerLock();
  }
  pointerLocked = false;
  renderer.domElement.style.cursor = gyroActive ? "auto" : "grab";
}

function updateHud() {
  if (!scoreDisplay) return;
  if (defeat) {
    scoreDisplay.textContent = "GAME OVER";
    return;
  }
  if (victoryAchieved) {
    scoreDisplay.textContent = "Victory! Press START to battle again";
    return;
  }
  if (!gameStarted) {
    scoreDisplay.textContent = "Press START to begin";
  } else {
    scoreDisplay.textContent = "Player HP: " + playerHealth + "/" + PLAYER_MAX_HEALTH + "  Boss HP: " + bossHealth + "/" + BOSS_MAX_HEALTH;
  }
}

function setScoreDamageFlash() {
  if (!scoreDisplay) return;
  scoreDisplay.classList.add("damage");
  setTimeout(() => scoreDisplay.classList.remove("damage"), 160);
}


function createBoss() {
  bossFloatingCrystals = [];
  bossEnergyRings = [];
  bossShoulders = [];
  bossWings = [];
  bossWeakPointGlow = 0;

  const group = new THREE.Group();

  const bodyGroup = new THREE.Group();

  const outerBody = new THREE.Mesh(
    new THREE.OctahedronGeometry(7, 0),
    new THREE.MeshStandardMaterial({
      color: 0x0099ff,
      metalness: 0.3,
      roughness: 0.1,
      transparent: true,
      opacity: 0.7,
      emissive: 0x0066ff,
      emissiveIntensity: 0.2
    })
  );
  outerBody.scale.y = 1.8;
  bodyGroup.add(outerBody);

  const innerBody = new THREE.Mesh(
    new THREE.OctahedronGeometry(5, 0),
    new THREE.MeshStandardMaterial({
      color: 0x00ccff,
      metalness: 0.7,
      roughness: 0.1,
      emissive: 0x0099ff,
      emissiveIntensity: 0.4
    })
  );
  innerBody.scale.y = 1.5;
  innerBody.castShadow = true;
  bodyGroup.add(innerBody);

  group.add(bodyGroup);

  const coreGroup = new THREE.Group();

  const coreMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x00ffff,
    emissiveIntensity: 2,
    metalness: 0.5,
    roughness: 0
  });
  bossCore = new THREE.Mesh(new THREE.IcosahedronGeometry(3, 1), coreMaterial);
  coreGroup.add(bossCore);

  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const miniCrystal = new THREE.Mesh(
      new THREE.TetrahedronGeometry(0.8, 0),
      coreMaterial.clone()
    );
    miniCrystal.position.set(
      Math.cos(angle) * 4,
      Math.sin(angle * 1.2) * 2.4,
      Math.sin(angle) * 4
    );
    bossFloatingCrystals.push(miniCrystal);
    coreGroup.add(miniCrystal);
  }

  group.add(coreGroup);

  for (let i = 0; i < 3; i++) {
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(8 + i * 2, 0.3, 8, 32),
      new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00ffff,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.6
      })
    );
    ring.rotation.x = Math.PI / 2;
    ring.position.y = (i - 1) * 3;
    bossEnergyRings.push(ring);
    group.add(ring);
  }

  for (const side of [-1, 1]) {
    const shoulderGroup = new THREE.Group();

    const shoulderMaterial = new THREE.MeshStandardMaterial({
      color: 0x00aaff,
      metalness: 0.8,
      roughness: 0.2,
      emissive: 0x0066ff,
      emissiveIntensity: 0.3
    });
    const shoulder = new THREE.Mesh(new THREE.OctahedronGeometry(4, 0), shoulderMaterial);
    shoulder.rotation.z = side * Math.PI / 6;
    shoulderGroup.add(shoulder);

    for (let j = 0; j < 3; j++) {
      const decor = new THREE.Mesh(new THREE.TetrahedronGeometry(1.5, 0), shoulderMaterial.clone());
      decor.position.set(
        side * 2 + Math.random() * 2 - 1,
        j * 2 - 2,
        Math.random() * 2 - 1
      );
      shoulderGroup.add(decor);
    }

    const cannonGroup = new THREE.Group();
    const cannonMaterial = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 1
    });
    const cannonCore = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), cannonMaterial);
    cannonGroup.add(cannonCore);

    for (let k = 0; k < 3; k++) {
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(2 + k * 0.5, 0.2, 8, 16),
        new THREE.MeshStandardMaterial({
          color: 0xff00ff,
          emissive: 0xff00ff,
          emissiveIntensity: 0.5
        })
      );
      ring.position.y = -k;
      cannonGroup.add(ring);
    }

    cannonGroup.position.y = -5;
    shoulderGroup.add(cannonGroup);

    const shoulderLight = new THREE.PointLight(0x00aaff, 2, 10);
    shoulderLight.position.set(0, 0, 0);
    shoulderGroup.add(shoulderLight);

    shoulderGroup.position.x = side * 12;
    shoulderGroup.position.y = 5;

    bossShoulders.push({
      group: shoulderGroup,
      cannon: cannonCore,
      phase: side === -1 ? 0 : Math.PI
    });
    group.add(shoulderGroup);
  }

  for (const side of [-1, 1]) {
    const wingGroup = new THREE.Group();

    for (let j = 0; j < 5; j++) {
      const wingMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00ffff,
        emissiveIntensity: 1.2,
        transparent: true,
        opacity: 0.8 - j * 0.1
      });
      const wingPart = new THREE.Mesh(new THREE.BoxGeometry(0.8, 10 - j * 1.5, 0.2), wingMaterial);
      wingPart.position.x = side * (j + 1) * 2.5;
      wingPart.position.y = -j * 1.5;
      wingPart.rotation.z = side * (Math.PI / 8 + j * 0.05);
      wingGroup.add(wingPart);

      const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1 - j * 0.15, 0), wingMaterial.clone());
      crystal.position.copy(wingPart.position);
      crystal.position.y += 2;
      wingGroup.add(crystal);
    }

    const wingGlow = new THREE.PointLight(0x00ffff, 3, 15);
    wingGlow.position.set(side * 8, 0, 0);
    wingGroup.add(wingGlow);

    wingGroup.position.x = side * 10;
    wingGroup.position.y = 5;
    wingGroup.position.z = -4;

    bossWings.push({ group: wingGroup, phase: side === -1 ? 0 : Math.PI });
    group.add(wingGroup);
  }

  const headGroup = new THREE.Group();
  const headMaterial = new THREE.MeshStandardMaterial({
    color: 0x0099ff,
    metalness: 0.9,
    roughness: 0.1,
    emissive: 0x0066ff,
    emissiveIntensity: 0.3
  });
  const head = new THREE.Mesh(new THREE.ConeGeometry(4, 6, 6), headMaterial);
  head.rotation.y = Math.PI / 6;
  headGroup.add(head);

  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.8, 3, 4), headMaterial.clone());
    spike.position.set(Math.cos(angle) * 3, 2, Math.sin(angle) * 3);
    spike.rotation.z = angle * 0.3;
    headGroup.add(spike);
  }

  headGroup.position.y = 12;
  group.add(headGroup);

  for (const side of [-1, 1]) {
    const eyeGroup = new THREE.Group();

    const eye = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    eyeGroup.add(eye);

    const eyeGlow = new THREE.Mesh(
      new THREE.SphereGeometry(1.8, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 })
    );
    eyeGroup.add(eyeGlow);

    const eyeLight = new THREE.PointLight(0xffffff, 5, 15);
    eyeGroup.add(eyeLight);

    eyeGroup.position.set(side * 2.5, 12, 2);
    group.add(eyeGroup);
  }

  const weakPointGroup = new THREE.Group();

  bossWeakPoint = new THREE.Mesh(
    new THREE.OctahedronGeometry(2, 1),
    new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 2,
      metalness: 0.5,
      roughness: 0
    })
  );
  weakPointGroup.add(bossWeakPoint);

  const weakPointLight = new THREE.PointLight(0xff0000, 10, 25);
  weakPointGroup.add(weakPointLight);

  weakPointGroup.position.set(0, 3, 5);
  group.add(weakPointGroup);

  const particleCount = 200;
  const particlesGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i++) {
    const radius = 15 + Math.random() * 5;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const index = i * 3;
    positions[index] = radius * Math.sin(phi) * Math.cos(theta);
    positions[index + 1] = radius * Math.sin(phi) * Math.sin(theta);
    positions[index + 2] = radius * Math.cos(phi);
  }
  particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  const particles = new THREE.Points(
    particlesGeometry,
    new THREE.PointsMaterial({ color: 0x00ffff, size: 0.3, transparent: true, opacity: 0.8 })
  );
  group.add(particles);

  group.position.copy(bossTargetPosition);
  group.scale.setScalar(BOSS_MODEL_SCALE);
  return group;
}

function initializeBoss() {
  updateBossTargetPositionFromPlayer();
  if (boss) {
    scene.remove(boss);
  }
  boss = createBoss();
  scene.add(boss);
}

function registerBossAttack(mesh, velocity, options) {
  options = options || {};
  mesh.position.addScaledVector(velocity.clone().normalize(), 0.2);
  scene.add(mesh);
  bossAttacks.push({
    mesh,
    velocity,
    life: options.life === undefined ? 4 : options.life,
    spin: options.spin || new THREE.Vector3(),
    damage: options.damage === undefined ? 1 : options.damage,
    homing: options.homing || false
  });
}

function clearBossAttacks() {
  for (let i = bossAttacks.length - 1; i >= 0; i--) {
    scene.remove(bossAttacks[i].mesh);
  }
  bossAttacks.length = 0;
}

function clearBossDeathPieces() {
  for (let i = bossDeathPieces.length - 1; i >= 0; i--) {
    scene.remove(bossDeathPieces[i].mesh);
  }
  bossDeathPieces.length = 0;
  isBossDying = false;
}

function clearBossHitEffects() {
  for (let i = bossHitEffects.length - 1; i >= 0; i--) {
    const effect = bossHitEffects[i];
    if (effect.ring) scene.remove(effect.ring);
    if (effect.backRing) scene.remove(effect.backRing);
    if (effect.glow) scene.remove(effect.glow);
    if (effect.core) scene.remove(effect.core);
    if (effect.light) scene.remove(effect.light);
    if (effect.sparks) {
      effect.sparks.forEach((spark) => {
        if (spark.mesh) scene.remove(spark.mesh);
      });
    }
    if (effect.arcs) {
      effect.arcs.forEach((arcData) => {
        if (arcData.line) scene.remove(arcData.line);
      });
    }
    if (effect.particles && effect.particles.points) {
      scene.remove(effect.particles.points);
    }
  }
  bossHitEffects.length = 0;
}

function flashBoss() {
  if (!boss) return;
  
  // 複数回の点滅エフェクト
  const flashSequence = [
    { delay: 0, intensity: 0.8, duration: 100 },
    { delay: 150, intensity: 0.6, duration: 100 },
    { delay: 300, intensity: 0.4, duration: 100 },
    { delay: 450, intensity: 0.2, duration: 100 }
  ];
  
  flashSequence.forEach((flash, index) => {
    setTimeout(() => {
      if (!boss) return;
      
      const flashColor = new THREE.Color(0xff0000);
      const flashEmissive = new THREE.Color(0xff0000);
      
      boss.traverse((child) => {
        if (child.isMesh && child !== bossWeakPoint) {
          const material = child.material;
          if (!material.userData) material.userData = {};
          if (!material.userData.originalColor) {
            material.userData.originalColor = material.color.clone();
          }
          if (material.emissive && !material.userData.originalEmissive) {
            material.userData.originalEmissive = material.emissive.clone();
          }
          
          // より強い赤色で点滅
          material.color.lerp(flashColor, flash.intensity);
          if (material.emissive) {
            material.emissive.lerp(flashEmissive, flash.intensity * 1.5);
          }
          
          setTimeout(() => {
            if (!material.userData || !boss) return;
            if (material.userData.originalColor) {
              material.color.copy(material.userData.originalColor);
            }
            if (material.emissive && material.userData.originalEmissive) {
              material.emissive.copy(material.userData.originalEmissive);
            }
          }, flash.duration);
        }
      });
    }, flash.delay);
  });
}

function spawnBossHitEffect(worldPosition) {
  const center = worldPosition.clone();
  const bossReference = boss; // ボスの参照を保存

  const ring = new THREE.Mesh(
    new THREE.RingGeometry(1.5, 3.5, 72, 1),
    new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.9,
      blending: THREE.NormalBlending,
      side: THREE.DoubleSide,
      depthWrite: true
    })
  );
  ring.position.copy(center);
  ring.lookAt(camera.position);
  scene.add(ring);

  const backRing = ring.clone();
  backRing.material = ring.material.clone();
  backRing.material.opacity = 0.6;
  scene.add(backRing);

  const glow = new THREE.Mesh(
    new THREE.SphereGeometry(1.2, 28, 28),
    new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      blending: THREE.NormalBlending,
      depthWrite: true
    })
  );
  glow.position.copy(center);
  scene.add(glow);

  const core = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.7, 2),
    new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 1.0,
      blending: THREE.NormalBlending,
      depthWrite: true
    })
  );
  core.position.copy(center);
  scene.add(core);

  const light = new THREE.PointLight(0xffff00, 25, 80);
  light.position.copy(center);
  scene.add(light);

  const sparks = [];
  const sparkPalette = [0xffff00, 0xff8800, 0xff4400, 0xff0044, 0x00ffff, 0xffffff];
  for (let i = 0; i < BOSS_HIT_SPARK_COUNT; i++) {
    const spark = new THREE.Mesh(
      new THREE.ConeGeometry(0.25, 1.8, 18),
      new THREE.MeshBasicMaterial({
        color: sparkPalette[Math.floor(Math.random() * sparkPalette.length)],
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      })
    );
    spark.position.copy(center);
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(2.0),
      THREE.MathUtils.randFloat(0.3, 2.0),
      THREE.MathUtils.randFloatSpread(2.0)
    ).normalize();
    const speed = THREE.MathUtils.randFloat(15, 35);
    const velocity = dir.multiplyScalar(speed);
    spark.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone());
    scene.add(spark);
    sparks.push({
      mesh: spark,
      velocity,
      rotationAxis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(),
      rotationSpeed: THREE.MathUtils.randFloat(-10, 10)
    });
  }

  const arcs = [];
  for (let i = 0; i < BOSS_HIT_ARC_COUNT; i++) {
    const segmentCount = THREE.MathUtils.randInt(4, 6);
    const basePoints = [];
    let current = new THREE.Vector3();
    basePoints.push(current.clone());
    const orientation = new THREE.Quaternion().setFromEuler(new THREE.Euler(
      THREE.MathUtils.randFloat(0, Math.PI * 2),
      THREE.MathUtils.randFloat(0, Math.PI * 2),
      THREE.MathUtils.randFloat(0, Math.PI * 2)
    ));
    for (let s = 0; s < segmentCount; s++) {
      const step = new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(0.9),
        THREE.MathUtils.randFloatSpread(0.9),
        THREE.MathUtils.randFloatSpread(0.9)
      )
        .normalize()
        .multiplyScalar(THREE.MathUtils.randFloat(0.8, 2.2));
      current = current.clone().add(step);
      basePoints.push(current.clone());
    }
    const rotated = basePoints.map((pt) => pt.clone().applyQuaternion(orientation));
    const geometry = new THREE.BufferGeometry().setFromPoints(rotated);
    const material = new THREE.LineBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 1.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      linewidth: 3
    });
    const arc = new THREE.Line(geometry, material);
    arc.position.copy(center);
    scene.add(arc);
    arcs.push({ line: arc, basePoints: rotated, material });
  }

  const particlePositions = new Float32Array(BOSS_HIT_PARTICLE_COUNT * 3);
  const particleVelocities = [];
  for (let i = 0; i < BOSS_HIT_PARTICLE_COUNT; i++) {
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(1.4),
      THREE.MathUtils.randFloatSpread(1.4),
      THREE.MathUtils.randFloatSpread(1.4)
    ).normalize();
    const speed = THREE.MathUtils.randFloat(9, 20);
    particleVelocities.push(dir.multiplyScalar(speed));
    particlePositions[i * 3 + 0] = center.x;
    particlePositions[i * 3 + 1] = center.y;
    particlePositions[i * 3 + 2] = center.z;
  }
  const particlesGeometry = new THREE.BufferGeometry();
  particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
  const particlesMaterial = new THREE.PointsMaterial({
    color: 0x00ffff,
    size: 0.3,
    transparent: true,
    opacity: 0.9,
    blending: THREE.NormalBlending,
    depthWrite: true
  });
  const particles = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particles);

  bossHitEffects.push({
    center,
    ring,
    backRing,
    glow,
    core,
    light,
    sparks,
    arcs,
    particles: {
      points: particles,
      geometry: particlesGeometry,
      material: particlesMaterial,
      velocities: particleVelocities,
      positions: particlePositions
    },
    life: BOSS_HIT_EFFECT_DURATION,
    maxLife: BOSS_HIT_EFFECT_DURATION,
    bossReference,
    offsetFromBoss: worldPosition.clone().sub(bossReference ? bossReference.position : new THREE.Vector3())
  });
}

function updateBossHitEffects(delta) {
  for (let i = bossHitEffects.length - 1; i >= 0; i--) {
    const effect = bossHitEffects[i];
    effect.life -= delta;
    const lifeRatio = Math.max(effect.life, 0) / effect.maxLife;
    const progress = 1 - lifeRatio;

    // ボスが停止中の場合のみ位置に追従
    if (effect.bossReference && effect.bossReference.position && bossStunned) {
      const newCenter = effect.bossReference.position.clone().add(effect.offsetFromBoss);
      effect.center.copy(newCenter);
      
      // エフェクトの位置を更新
      if (effect.ring) effect.ring.position.copy(newCenter);
      if (effect.backRing) effect.backRing.position.copy(newCenter);
      if (effect.glow) effect.glow.position.copy(newCenter);
      if (effect.core) effect.core.position.copy(newCenter);
      if (effect.light) effect.light.position.copy(newCenter);
      
      // スパークの位置は移動するので、初期位置のみ更新
      // スパークは既に移動しているので、位置をリセットしない
      
      // アークの位置を更新
      if (effect.arcs) {
        effect.arcs.forEach((arcData) => {
          if (arcData.line) {
            arcData.line.position.copy(newCenter);
          }
        });
      }
      
      // パーティクルの位置は移動するので、初期位置のみ更新
      // パーティクルは既に移動しているので、位置をリセットしない
    }

    if (effect.ring) {
      const ringScale = 1 + progress * (BOSS_HIT_RING_MAX_SCALE - 1);
      effect.ring.scale.setScalar(ringScale);
      effect.ring.lookAt(camera.position);
      if (effect.ring.material) {
        effect.ring.material.opacity = THREE.MathUtils.lerp(0.9, 0, Math.pow(progress, 0.9));
      }
    }

    if (effect.backRing) {
      const ringScale = 1 + progress * (BOSS_HIT_RING_MAX_SCALE * 1.2 - 1);
      effect.backRing.scale.setScalar(ringScale);
      effect.backRing.lookAt(camera.position);
      if (effect.backRing.material) {
        effect.backRing.material.opacity = THREE.MathUtils.lerp(0.6, 0, progress);
      }
    }

    if (effect.glow) {
      const glowScale = 1.2 + progress * 4.0;
      effect.glow.scale.setScalar(glowScale);
      if (effect.glow.material) {
        effect.glow.material.opacity = THREE.MathUtils.lerp(0.9, 0, Math.pow(progress, 1.1));
      }
    }

    if (effect.core) {
      const coreScale = 0.7 + Math.sin(progress * Math.PI * 2) * 0.3 + progress * 1.2;
      effect.core.scale.setScalar(coreScale);
      effect.core.rotation.x += delta * 6;
      effect.core.rotation.y += delta * 7;
      effect.core.material.opacity = THREE.MathUtils.lerp(1.0, 0, progress);
    }

    if (effect.light) {
      effect.light.intensity = THREE.MathUtils.lerp(25, 0, progress);
      effect.light.distance = THREE.MathUtils.lerp(80, 20, progress);
    }

    if (effect.sparks) {
      effect.sparks.forEach((sparkData) => {
        if (!sparkData.mesh) return;
        sparkData.velocity.multiplyScalar(1 - delta * 0.3);
        sparkData.velocity.y -= delta * 8;
        sparkData.mesh.position.addScaledVector(sparkData.velocity, delta);
        sparkData.mesh.rotateOnAxis(sparkData.rotationAxis, sparkData.rotationSpeed * delta);
        const mat = sparkData.mesh.material;
        if (mat) {
          mat.opacity = Math.max(0, 1 - progress * 0.8);
        }
        if (sparkData.mesh.position.distanceToSquared(effect.center) > 1600) {
          scene.remove(sparkData.mesh);
          sparkData.mesh = null;
        }
      });
    }

    if (effect.arcs) {
      effect.arcs.forEach((arcData) => {
        if (!arcData.line) return;
        const positions = arcData.line.geometry.attributes.position;
        for (let p = 0; p < arcData.basePoints.length; p++) {
          const base = arcData.basePoints[p];
          const jitter = (1 - progress) * 0.45;
          positions.setXYZ(
            p,
            base.x + THREE.MathUtils.randFloatSpread(jitter),
            base.y + THREE.MathUtils.randFloatSpread(jitter),
            base.z + THREE.MathUtils.randFloatSpread(jitter)
          );
        }
        positions.needsUpdate = true;
        if (arcData.material) {
          arcData.material.opacity = THREE.MathUtils.lerp(1.0, 0, progress);
        }
      });
    }

    if (effect.particles) {
      const positions = effect.particles.positions;
      const velocities = effect.particles.velocities;
      for (let p = 0; p < velocities.length; p++) {
        const vel = velocities[p];
        vel.multiplyScalar(1 - delta * 0.4);
        vel.y -= delta * 7;
        const idx = p * 3;
        positions[idx + 0] += vel.x * delta;
        positions[idx + 1] += vel.y * delta;
        positions[idx + 2] += vel.z * delta;
      }
      effect.particles.geometry.attributes.position.needsUpdate = true;
      if (effect.particles.material) {
        effect.particles.material.opacity = Math.max(0, 0.9 - progress * 1.3);
      }
    }

    if (effect.life <= 0) {
      if (effect.ring) scene.remove(effect.ring);
      if (effect.backRing) scene.remove(effect.backRing);
      if (effect.glow) scene.remove(effect.glow);
      if (effect.core) scene.remove(effect.core);
      if (effect.light) scene.remove(effect.light);
      if (effect.sparks) {
        effect.sparks.forEach((sparkData) => {
          if (sparkData.mesh) scene.remove(sparkData.mesh);
        });
      }
      if (effect.arcs) {
        effect.arcs.forEach((arcData) => {
          if (arcData.line) scene.remove(arcData.line);
        });
      }
      if (effect.particles && effect.particles.points) {
        scene.remove(effect.particles.points);
      }
      bossHitEffects.splice(i, 1);
    }
  }
}

function startBossDeathSequence() {
  if (!boss) return;
  victoryAchieved = true;
  gameActive = false;
  gameStarted = false;
  isBossDying = true;
  showStartButton("RESTART");

  const origin = new THREE.Vector3();
  boss.getWorldPosition(origin);
  scene.remove(boss);
  boss = null;
  bossWeakPoint = null;
  bossCore = null;

  for (let i = 0; i < 36; i++) {
    const shard = new THREE.Mesh(
      new THREE.TetrahedronGeometry(THREE.MathUtils.randFloat(0.3, 0.8), 0),
      new THREE.MeshStandardMaterial({
        color: 0x7cd3ff,
        emissive: 0x4fe0ff,
        emissiveIntensity: 0.9,
        transparent: true,
        opacity: 1
      })
    );
    shard.position.copy(origin);
    shard.position.x += THREE.MathUtils.randFloatSpread(1.5);
    shard.position.y += THREE.MathUtils.randFloatSpread(1.5);
    shard.position.z += THREE.MathUtils.randFloatSpread(1.5);
    scene.add(shard);
    bossDeathPieces.push({
      mesh: shard,
      velocity: new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(14),
        THREE.MathUtils.randFloat(3, 16),
        THREE.MathUtils.randFloatSpread(14)
      ),
      angular: new THREE.Vector3(
        THREE.MathUtils.randFloat(-8, 8),
        THREE.MathUtils.randFloat(-8, 8),
        THREE.MathUtils.randFloat(-8, 8)
      ),
      life: 2.2
    });
  }

  const flash = new THREE.PointLight(0x88ccff, 90, 80);
  flash.position.copy(origin);
  scene.add(flash);
  setTimeout(() => scene.remove(flash), 400);
  updateHud();
}

function startBattle() {
  clearBossAttacks();
  clearBossDeathPieces();
  clearBossHitEffects();
  playerHealth = PLAYER_MAX_HEALTH;
  bossHealth = BOSS_MAX_HEALTH;
  shootCooldownTimer = 0;
  attackCooldownTimer = THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
  bossMoveTimer = 0;
  bossTime = 0;
  bossHitReaction = 0;
  bossAttackPattern = 0;
  bossStunned = false;
  bossStunTimer = 0;
  bossFlashTimer = 0;
  victoryAchieved = false;
  defeat = false;
  gameStarted = true;
  gameActive = true;
  hideStartButton();

  setBossTargetAroundPlayer();

  if (!boss) {
    initializeBoss();
  }
  if (boss) {
    boss.position.copy(bossTargetPosition);
    boss.rotation.set(0, 0, 0);
    tmpVecA.subVectors(camera.position, boss.position);
    boss.rotation.y = Math.atan2(tmpVecA.x, tmpVecA.z);
    boss.scale.set(1, 1, 1);
  }

  updateHud();
}

function applyPlayerDamage(amount) {
  if (victoryAchieved || defeat) return;
  playerHealth = Math.max(0, playerHealth - (amount || 1));
  setScoreDamageFlash();
  if (playerHealth <= 0) {
    defeat = true;
    gameActive = false;
    gameStarted = false;
    showStartButton("RESTART");
    clearBossAttacks();
  }
  updateHud();
}

function handleBossHit(worldPosition) {
  if (!gameActive || victoryAchieved || !bossWeakPoint || bossStunned) return;
  
  // ボスを停止状態にする
  bossStunned = true;
  bossStunTimer = bossStunDuration;
  bossFlashTimer = bossFlashDuration;
  
  bossHealth = Math.max(0, bossHealth - 1);
  bossHitReaction = 1;
  bossMoveTimer = 0;
  // 停止中は移動しないので、setBossTargetAroundPlayer()を呼ばない

  const flash = new THREE.PointLight(0xffff80, 26, 40);
  flash.position.copy(worldPosition);
  scene.add(flash);
  setTimeout(() => scene.remove(flash), 200);

  flashBoss();
  spawnBossHitEffect(worldPosition);
  updateHud();

  if (bossHealth <= 0) {
    startBossDeathSequence();
  }
}

function createBullet() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 12, 12),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
  );
  camera.getWorldPosition(bulletStartPosition);
  camera.getWorldDirection(bulletDirection);
  bulletDirection.normalize();
  bullet.position.copy(bulletStartPosition).addScaledVector(bulletDirection, 0.6);
  scene.add(bullet);
  bullets.push({ mesh: bullet, velocity: bulletDirection.clone().multiplyScalar(BULLET_SPEED), life: BULLET_LIFETIME });
}

function shoot() {
  if (!gameStarted || !gameActive || shootCooldownTimer > 0) {
    return;
  }
  shootCooldownTimer = SHOOT_COOLDOWN;
  createBullet();
  if (crosshair) {
    crosshair.classList.remove("flash");
    void crosshair.offsetWidth;
    crosshair.classList.add("flash");
  }
}
function updateBullets(delta) {
  if (bullets.length === 0) return;
  const weakPointPosition = new THREE.Vector3();
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bulletData = bullets[i];
    bulletData.life -= delta;
    bulletData.mesh.position.addScaledVector(bulletData.velocity, delta);
    if (bulletData.life <= 0) {
      scene.remove(bulletData.mesh);
      bullets.splice(i, 1);
      continue;
    }
    if (bossWeakPoint && gameActive && !victoryAchieved) {
      bossWeakPoint.getWorldPosition(weakPointPosition);
      if (bulletData.mesh.position.distanceTo(weakPointPosition) <= BOSS_WEAK_POINT_RADIUS) {
        handleBossHit(weakPointPosition.clone());
        scene.remove(bulletData.mesh);
        bullets.splice(i, 1);
      }
    }
  }
}

function updateBossAttacks(delta) {
  for (let i = bossAttacks.length - 1; i >= 0; i--) {
    const attack = bossAttacks[i];
    if (!attack) {
      continue;
    }
    attack.life -= delta;
    if (attack.homing && gameActive) {
      tmpVecA.copy(camera.position).sub(attack.mesh.position).normalize();
      const speed = attack.velocity.length();
      attack.velocity.lerp(tmpVecA.multiplyScalar(speed), delta * 0.9);
    }
    attack.mesh.position.addScaledVector(attack.velocity, delta);
    attack.mesh.rotation.x += attack.spin.x * delta;
    attack.mesh.rotation.y += attack.spin.y * delta;
    attack.mesh.rotation.z += attack.spin.z * delta;

    if (attack.life <= 0 || attack.mesh.position.distanceToSquared(camera.position) > 40000) {
      scene.remove(attack.mesh);
      bossAttacks.splice(i, 1);
      continue;
    }

    if (!victoryAchieved && !defeat) {
      if (attack.mesh.position.distanceTo(camera.position) <= PLAYER_HIT_RADIUS) {
        scene.remove(attack.mesh);
        bossAttacks.splice(i, 1);
        applyPlayerDamage(attack.damage);
        if (bossAttacks.length === 0) {
          break;
        }
        continue;
      }
    }
  }
}

function updateBossDeath(delta) {
  if (!isBossDying) return;
  for (let i = bossDeathPieces.length - 1; i >= 0; i--) {
    const piece = bossDeathPieces[i];
    piece.life -= delta;
    piece.mesh.position.addScaledVector(piece.velocity, delta);
    piece.velocity.y -= 9.8 * delta * 0.4;
    piece.mesh.rotation.x += piece.angular.x * delta;
    piece.mesh.rotation.y += piece.angular.y * delta;
    piece.mesh.rotation.z += piece.angular.z * delta;
    if (piece.mesh.material && "opacity" in piece.mesh.material) {
      piece.mesh.material.opacity = Math.max(0, piece.life / 2.2);
    }
    if (piece.life <= 0) {
      scene.remove(piece.mesh);
      bossDeathPieces.splice(i, 1);
    }
  }
  if (bossDeathPieces.length === 0) {
    isBossDying = false;
  }
}

function shootFocusedVolley() {
  if (!boss) return;
  const muzzle = new THREE.Vector3(boss.position.x, boss.position.y + 4.2, boss.position.z + 0.6);
  tmpVecA.subVectors(camera.position, muzzle).normalize();
  const spreads = [-6, 0, 6];
  for (let i = 0; i < spreads.length; i++) {
    const dir = tmpVecA.clone().applyAxisAngle(worldUp, THREE.MathUtils.degToRad(spreads[i]));
    dir.y += THREE.MathUtils.randFloat(-0.05, 0.05);
    dir.normalize();
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.95, 18, 18),
      new THREE.MeshBasicMaterial({ color: 0xff44ff, transparent: true, opacity: 0.9 })
    );
    orb.position.copy(muzzle);
    registerBossAttack(orb, dir.multiplyScalar(24), {
      life: 4,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-3, 3),
        THREE.MathUtils.randFloat(-3, 3),
        THREE.MathUtils.randFloat(-3, 3)
      )
    });
  }
  const burst = new THREE.PointLight(0xff66ff, 16, 28);
  burst.position.copy(muzzle);
  scene.add(burst);
  setTimeout(() => scene.remove(burst), 220);
}

function shootCrystalSpread() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 4.8, boss.position.z);
  for (let i = -2; i <= 2; i++) {
    const shard = new THREE.Mesh(
      new THREE.OctahedronGeometry(0.7, 0),
      new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.85 })
    );
    shard.position.copy(origin);
    tmpVecA.subVectors(camera.position, origin).normalize();
    tmpVecA.applyAxisAngle(worldUp, THREE.MathUtils.degToRad(i * 4.5));
    tmpVecA.y += THREE.MathUtils.randFloat(-0.08, 0.08);
    tmpVecA.normalize();
    registerBossAttack(shard, tmpVecA.multiplyScalar(20 + Math.abs(i) * 2), {
      life: 3.6,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4),
        THREE.MathUtils.randFloat(-4, 4)
      )
    });
  }
}

function shootRadialVolley() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 3.6, boss.position.z);
  const count = 16;
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2;
    const bolt = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 12, 12),
      new THREE.MeshBasicMaterial({ color: 0x44ffee, transparent: true, opacity: 0.75 })
    );
    bolt.position.copy(origin);
    const dir = new THREE.Vector3(
      Math.cos(angle),
      THREE.MathUtils.randFloat(-0.15, 0.15),
      Math.sin(angle)
    );
    registerBossAttack(bolt, dir.normalize().multiplyScalar(18), {
      life: 4.5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2),
        THREE.MathUtils.randFloat(-2, 2)
      )
    });
  }
  const ringLight = new THREE.PointLight(0x33ffee, 18, 32);
  ringLight.position.copy(origin);
  scene.add(ringLight);
  setTimeout(() => scene.remove(ringLight), 320);
}

function shootHomingShards() {
  if (!boss) return;
  const origin = new THREE.Vector3(boss.position.x, boss.position.y + 3.2, boss.position.z);
  for (let i = 0; i < 5; i++) {
    const shard = new THREE.Mesh(
      new THREE.TetrahedronGeometry(0.9, 0),
      new THREE.MeshBasicMaterial({ color: 0xffff66, transparent: true, opacity: 0.85 })
    );
    shard.position.copy(origin);
    const dir = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.6),
      THREE.MathUtils.randFloat(-0.1, 0.4),
      THREE.MathUtils.randFloatSpread(0.6)
    ).normalize();
    registerBossAttack(shard, dir.multiplyScalar(12), {
      life: 5,
      spin: new THREE.Vector3(
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5),
        THREE.MathUtils.randFloat(-5, 5)
      ),
      homing: true
    });
  }
  const glow = new THREE.PointLight(0xffff66, 12, 28);
  glow.position.copy(origin);
  scene.add(glow);
  setTimeout(() => scene.remove(glow), 260);
}

function performBossAttack() {
  if (!gameActive || victoryAchieved || defeat || bossStunned) return;
  switch (bossAttackPattern) {
    case 0:
      shootFocusedVolley();
      break;
    case 1:
      shootCrystalSpread();
      break;
    case 2:
      shootRadialVolley();
      break;
    default:
      shootHomingShards();
      break;
  }
  bossAttackPattern = (bossAttackPattern + 1) % 4;
  attackCooldownTimer = THREE.MathUtils.randFloat(BOSS_ATTACK_COOLDOWN_MIN, BOSS_ATTACK_COOLDOWN_MAX);
}


function updateBossBehavior(delta) {
  if (!boss || !gameActive) return;
  bossTime += delta;
  bossMoveTimer += delta;
  bossHitReaction = Math.max(0, bossHitReaction - delta * 1.5);

  // 停止状態の管理
  if (bossStunned) {
    bossStunTimer -= delta;
    bossFlashTimer -= delta;
    
    // 点滅エフェクトの管理
    if (bossFlashTimer > 0) {
      const flashIntensity = Math.sin(bossFlashTimer * 20) * 0.5 + 0.5;
      const flashColor = new THREE.Color(0xff0000);
      const flashEmissive = new THREE.Color(0xff0000);
      
      boss.traverse((child) => {
        if (child.isMesh && child !== bossWeakPoint) {
          const material = child.material;
          if (!material.userData) material.userData = {};
          if (!material.userData.originalColor) {
            material.userData.originalColor = material.color.clone();
          }
          if (material.emissive && !material.userData.originalEmissive) {
            material.userData.originalEmissive = material.emissive.clone();
          }
          
          // 連続的な点滅
          material.color.lerp(flashColor, flashIntensity * 0.6);
          if (material.emissive) {
            material.emissive.lerp(flashEmissive, flashIntensity * 0.8);
          }
        }
      });
    } else {
      // 点滅が終わったら元の色に戻す
      boss.traverse((child) => {
        if (child.isMesh && child !== bossWeakPoint) {
          const material = child.material;
          if (material.userData && material.userData.originalColor) {
            material.color.copy(material.userData.originalColor);
          }
          if (material.emissive && material.userData && material.userData.originalEmissive) {
            material.emissive.copy(material.userData.originalEmissive);
          }
        }
      });
    }
    
    if (bossStunTimer <= 0) {
      bossStunned = false;
      // 停止が終わったら新しい位置を設定
      setBossTargetAroundPlayer();
    }
    // 停止中は移動しないが、アニメーションは続ける
    // アニメーション部分は下に移動
  } else {
    // 通常時のみ移動処理
    updateBossTargetPositionFromPlayer();

    if (bossMoveTimer >= BOSS_MOVE_INTERVAL) {
      bossMoveTimer = 0;
      setBossTargetAroundPlayer();
    }

    boss.position.x += (bossTargetPosition.x - boss.position.x) * delta * 2.4;
    boss.position.z += (bossTargetPosition.z - boss.position.z) * delta * 2.4;
  }

  // 高さのアニメーション（停止中でも続く）
  const idleHeight = BOSS_BASE_HEIGHT + Math.sin(bossTime * 2.2) * 0.6;
  boss.position.y = idleHeight + bossHitReaction * 0.6;

  tmpVecA.subVectors(camera.position, boss.position);
  const horizontalDistance = Math.hypot(tmpVecA.x, tmpVecA.z) || 0.0001;
  const desiredYaw = Math.atan2(tmpVecA.x, tmpVecA.z);
  const desiredPitch = Math.atan2(tmpVecA.y, horizontalDistance);
  const orientationLerp = 1 - Math.exp(-delta * 8);

  let yawDiff = desiredYaw - boss.rotation.y;
  yawDiff = THREE.MathUtils.euclideanModulo(yawDiff + Math.PI, Math.PI * 2) - Math.PI;
  boss.rotation.y += yawDiff * orientationLerp;
  boss.rotation.x = THREE.MathUtils.lerp(boss.rotation.x, -desiredPitch * 0.6 + bossHitReaction * 0.12, orientationLerp);

  const leanTarget = THREE.MathUtils.clamp((bossTargetPosition.x - boss.position.x) * -0.03, -0.35, 0.35);
  boss.rotation.z = THREE.MathUtils.lerp(boss.rotation.z, leanTarget, orientationLerp);

  if (bossHitReaction > 0) {
    boss.position.x += Math.sin(bossTime * 42) * bossHitReaction * 1.6;
    boss.position.y += Math.cos(bossTime * 38) * bossHitReaction * 0.9;
  }

  if (bossCore) {
    bossCore.rotation.x += delta * 2.6;
    bossCore.rotation.y += delta * 3.1;
    const scale = 1 + Math.sin(bossTime * 4.2) * 0.1 + bossHitReaction * 0.05;
    bossCore.scale.setScalar(scale);
  }

  bossFloatingCrystals.forEach((crystal, index) => {
    const angle = bossTime * 2 + (index / bossFloatingCrystals.length) * Math.PI * 2;
    crystal.position.x = Math.cos(angle) * 4;
    crystal.position.z = Math.sin(angle) * 4;
    crystal.position.y = Math.sin(bossTime * 3 + index) * 2.2;
    crystal.rotation.x += delta * 5;
    crystal.rotation.y += delta * 3;
  });

  bossEnergyRings.forEach((ring, index) => {
    ring.rotation.z += delta * (1 + index * 0.5);
    const scale = 1 + Math.sin(bossTime * 2.2 + index) * 0.1;
    ring.scale.setScalar(scale);
  });

  bossShoulders.forEach((data) => {
    const offset = data.phase || 0;
    data.group.position.y = 5 + Math.sin(bossTime * 2 + offset) * 2;
    data.group.rotation.z = Math.sin(bossTime * 1.5 + offset) * 0.3;
    if (data.cannon && data.cannon.material && data.cannon.material.emissive) {
      data.cannon.material.emissiveIntensity = 1 + Math.sin(bossTime * 6 + offset) * 0.5;
    }
  });

  bossWings.forEach((data) => {
    const offset = data.phase || 0;
    data.group.rotation.y = Math.sin(bossTime * 2 + offset) * 0.5;
    data.group.position.z = -4 + Math.sin(bossTime * 3 + offset) * 2;
  });

  if (bossWeakPoint) {
    bossWeakPointGlow += delta;
    const pulse = 1 + Math.sin(bossWeakPointGlow * 6) * 0.35;
    bossWeakPoint.scale.setScalar(pulse);
    if (bossWeakPoint.material && bossWeakPoint.material.emissive) {
      bossWeakPoint.material.emissiveIntensity = 2 + Math.sin(bossWeakPointGlow * 8) * 0.6;
    }
    bossWeakPoint.rotation.x += delta * 3;
    bossWeakPoint.rotation.z += delta * 2;
  }
}

function applyCameraRotation() {
  cameraEuler.set(pitch, yaw, 0);
  camera.quaternion.setFromEuler(cameraEuler);
}

function updateMovement(delta) {
  const joystickX = Math.abs(moveJoystickData.x) > 0.01 ? moveJoystickData.x : 0;
  const joystickY = Math.abs(moveJoystickData.y) > 0.01 ? moveJoystickData.y : 0;
  inputVector.set(joystickX, 0, -joystickY);
  if (inputVector.x === 0 && inputVector.z === 0) return;
  if (inputVector.lengthSq() > 1) {
    inputVector.normalize();
  }
  forwardVector.set(0, 0, -1).applyQuaternion(camera.quaternion);
  forwardVector.y = 0;
  if (forwardVector.lengthSq() > 0.0001) {
    forwardVector.normalize();
  } else {
    forwardVector.set(0, 0, -1);
  }
  rightVector.crossVectors(forwardVector, worldUp);
  if (rightVector.lengthSq() > 0.0001) {
    rightVector.normalize();
  } else {
    rightVector.set(1, 0, 0);
  }
  displacement.copy(forwardVector).multiplyScalar(inputVector.z);
  displacement.addScaledVector(rightVector, inputVector.x);
  if (displacement.lengthSq() === 0) return;
  displacement.normalize().multiplyScalar((isMobile ? MOBILE_MOVE_SPEED : MOVE_SPEED) * delta);
  camera.position.add(displacement);
  camera.position.y = 1.6;
}

function handleResize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
  renderer.setPixelRatio(dpr);
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

handleResize();
window.addEventListener("resize", handleResize);

const spark = new SparkRenderer({
  renderer,
  maxStdDev: Math.sqrt(5),
  maxPixelRadius: 256,
  clipXY: 2.0,
  view: { stochastic: false, sortRadial: true, sortDistance: 0.01, sortCoorient: 0.995, sort32: false }
});
scene.add(spark);

const loadingEl = document.getElementById("loading");
const splat = new SplatMesh({
  url: SPZ_URL,
  onLoad: () => {
    if (loadingEl) loadingEl.remove();
    renderer.render(scene, camera);
  }
});
splat.scale.setScalar(5);
splat.position.set(0, -1.2, -8);
splat.rotation.set(Math.PI, 0, 0);
scene.add(splat);

function createGyroControls() {
  const deviceOrientation = { alpha: null, beta: null, gamma: null };
  let screenOrientation = window.orientation || 0;
  const zee = new THREE.Vector3(0, 0, 1);
  const euler = new THREE.Euler();
  const q0 = new THREE.Quaternion();
  const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

  const onDeviceOrientationChangeEvent = (event) => {
    deviceOrientation.alpha = event.alpha;
    deviceOrientation.beta = event.beta;
    deviceOrientation.gamma = event.gamma;
  };

  const onScreenOrientationChangeEvent = () => {
    screenOrientation = window.orientation || 0;
  };

  return {
    connect() {
      onScreenOrientationChangeEvent();
      window.addEventListener("orientationchange", onScreenOrientationChangeEvent);
      window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent);
    },
    disconnect() {
      window.removeEventListener("orientationchange", onScreenOrientationChangeEvent);
      window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent);
    },
    update() {
      if (deviceOrientation.alpha === null && deviceOrientation.beta === null && deviceOrientation.gamma === null) {
        return;
      }
      const alpha = deviceOrientation.alpha !== null ? THREE.MathUtils.degToRad(deviceOrientation.alpha) : 0;
      const beta = deviceOrientation.beta !== null ? THREE.MathUtils.degToRad(deviceOrientation.beta) : 0;
      const gamma = deviceOrientation.gamma !== null ? THREE.MathUtils.degToRad(deviceOrientation.gamma) : 0;
      const orient = THREE.MathUtils.degToRad(screenOrientation);
      euler.set(beta, alpha, -gamma, "YXZ");
      camera.quaternion.setFromEuler(euler);
      camera.quaternion.multiply(q1);
      camera.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
      cameraEuler.setFromQuaternion(camera.quaternion);
      pitch = cameraEuler.x;
      yaw = cameraEuler.y;
    }
  };
}

async function setupGyroscope() {
  if (!isMobile || gyroActive || typeof DeviceOrientationEvent === "undefined") {
    return false;
  }
  if (typeof DeviceOrientationEvent.requestPermission === "function") {
    try {
      const permission = await DeviceOrientationEvent.requestPermission();
      if (permission !== "granted") {
        return false;
      }
    } catch (error) {
      console.error("Failed to enable gyroscope:", error);
      return false;
    }
  }
  if (!gyroControls) {
    gyroControls = createGyroControls();
    gyroControls.connect();
  }
  gyroActive = true;
  isGyroAvailable = true;
  touchLookActive = false;
  if (document.pointerLockElement) {
    document.exitPointerLock();
  }
  pointerLocked = false;
  renderer.domElement.style.cursor = "auto";
  if (gyroPermissionEl) {
    gyroPermissionEl.style.display = "none";
  }
  return true;
}

function setupJoystick(container, stick, callback) {
  let active = false;
  let currentX = 0;
  let currentY = 0;
  const maxDistance = 45;

  function updateStickPosition() {
    stick.style.transform = "translate(calc(-50% + " + currentX + "px), calc(-50% + " + currentY + "px))";
  }

  function handleStart(e) {
    active = true;
    if (e.cancelable !== false) e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = container.getBoundingClientRect();
    currentX = touch.clientX - rect.left - rect.width / 2;
    currentY = touch.clientY - rect.top - rect.height / 2;
    const distance = Math.sqrt(currentX * currentX + currentY * currentY);
    if (distance > maxDistance) {
      currentX = currentX / distance * maxDistance;
      currentY = currentY / distance * maxDistance;
    }
    updateStickPosition();
    callback({ x: currentX / maxDistance, y: currentY / maxDistance });
  }

  function handleMove(e) {
    if (!active) return;
    if (e.cancelable !== false) e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = container.getBoundingClientRect();
    currentX = touch.clientX - rect.left - rect.width / 2;
    currentY = touch.clientY - rect.top - rect.height / 2;
    const distance = Math.sqrt(currentX * currentX + currentY * currentY);
    if (distance > maxDistance) {
      currentX = currentX / distance * maxDistance;
      currentY = currentY / distance * maxDistance;
    }
    updateStickPosition();
    callback({ x: currentX / maxDistance, y: currentY / maxDistance });
  }

  function handleEnd() {
    active = false;
    currentX = 0;
    currentY = 0;
    updateStickPosition();
    callback({ x: 0, y: 0 });
  }

  container.addEventListener("touchstart", handleStart, { passive: false });
  document.addEventListener("touchmove", handleMove, { passive: false });
  document.addEventListener("touchend", handleEnd);
  document.addEventListener("touchcancel", handleEnd);
  container.addEventListener("mousedown", handleStart);
  document.addEventListener("mousemove", handleMove);
  document.addEventListener("mouseup", handleEnd);
  updateStickPosition();
}

function onTouchStartLook(event) {
  if (!isMobile || gyroActive) return;
  if (event.target && typeof event.target.closest === "function") {
    if (event.target.closest("#moveJoystick") || event.target.closest("#shootButton")) {
      return;
    }
  }
  const touch = event.touches && event.touches[0];
  if (!touch) return;
  touchLookActive = true;
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
  if (event.cancelable !== false) event.preventDefault();
}

function onTouchMoveLook(event) {
  if (!touchLookActive || gyroActive) return;
  const touch = event.touches && event.touches[0];
  if (!touch) return;
  const deltaX = touch.clientX - lastTouchX;
  const deltaY = touch.clientY - lastTouchY;
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
  yaw -= deltaX * POINTER_SENSITIVITY;
  pitch -= deltaY * POINTER_SENSITIVITY;
  pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
  applyCameraRotation();
  if (event.cancelable !== false) event.preventDefault();
}

function onTouchEndLook() {
  touchLookActive = false;
}

if (requestGyroButton) {
  requestGyroButton.addEventListener("click", async () => {
    const enabled = await setupGyroscope();
    if (!enabled && gyroPermissionEl) {
      gyroPermissionEl.style.display = "flex";
    }
  });
}

if (isMobile && gyroPermissionEl && typeof DeviceOrientationEvent !== "undefined") {
  if (typeof DeviceOrientationEvent.requestPermission === "function") {
    gyroPermissionEl.style.display = "flex";
  } else {
    setupGyroscope();
  }
}

if (isMobile) {
  if (mobileUI) mobileUI.style.display = "block";
  renderer.domElement.style.touchAction = "none";
  if (moveJoystick && moveStick) {
    setupJoystick(moveJoystick, moveStick, (data) => {
      moveJoystickData = data;
    });
  }
}

renderer.domElement.addEventListener("touchstart", onTouchStartLook, { passive: false });
renderer.domElement.addEventListener("touchmove", onTouchMoveLook, { passive: false });
renderer.domElement.addEventListener("touchend", onTouchEndLook);
renderer.domElement.addEventListener("touchcancel", onTouchEndLook);

document.addEventListener("mousemove", (event) => {
  if (!pointerLocked || gyroActive) return;
  yaw -= event.movementX * POINTER_SENSITIVITY;
  pitch -= event.movementY * POINTER_SENSITIVITY;
  pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
  applyCameraRotation();
});

if (shootButton) {
  shootButton.addEventListener("click", (event) => {
    event.preventDefault();
    shoot();
  });
  shootButton.addEventListener("touchstart", (event) => {
    if (event.cancelable !== false) event.preventDefault();
    shoot();
  }, { passive: false });
}
if (startButton) {
  const triggerStartBattle = () => {
    if (gameActive) return;
    if (!isMobile && !gyroActive) {
      renderer.domElement.requestPointerLock();
    }
    startBattle();
  };
  startButton.addEventListener("click", (event) => {
    event.preventDefault();
    triggerStartBattle();
  });
  startButton.addEventListener("touchstart", (event) => {
    if (event.cancelable !== false) event.preventDefault();
    triggerStartBattle();
  }, { passive: false });
}


document.addEventListener("mousedown", (event) => {
  if (event.button === 0 && !isMobile && !gyroActive && pointerLocked) {
    shoot();
  }
});

renderer.domElement.addEventListener("click", () => {
  if (gyroActive || isMobile) return;
  if (!pointerLocked) {
    renderer.domElement.requestPointerLock();
  }
});

document.addEventListener("pointerlockchange", () => {
  pointerLocked = document.pointerLockElement === renderer.domElement;
  renderer.domElement.style.cursor = pointerLocked ? "none" : (gyroActive ? "auto" : "grab");
});

setBossTargetAroundPlayer();
initializeBoss();
updateHud();
showStartButton();

renderer.setAnimationLoop(() => {
  const delta = clock.getDelta();
  if (gyroActive && gyroControls && isGyroAvailable) {
    gyroControls.update();
  }
  if (shootCooldownTimer > 0) {
    shootCooldownTimer = Math.max(0, shootCooldownTimer - delta);
  }
  if (gameActive && !victoryAchieved && !defeat) {
    attackCooldownTimer -= delta;
    if (attackCooldownTimer <= 0) {
      performBossAttack();
    }
  }
  updateBossBehavior(delta);
  updateMovement(delta);
  updateBullets(delta);
  updateBossAttacks(delta);
  updateBossHitEffects(delta);
  updateBossDeath(delta);
  renderer.render(scene, camera);
});

</script>

</body>
</html>





